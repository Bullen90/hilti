#! /usr/bin/env python
#
# Main test driver.

import os
import os.path
import sys
import shutil
import fnmatch
import optparse
import re
import tempfile
import subprocess
import copy
import glob

Name ="tester"
Glob = "test-*"
Version = 0.1

TmpDir = ".tmp"
BaselineDir = ".baseline"
BinDir = None

# Commands as tuple (tag, regexp, more-than-one-is-ok, optional, group-main, group-add)
RE_EXEC = ("exec", re.compile("@TEST-EXEC(-FAIL)?: *(.*)"), True, False, 2, 1)
# RE_NAME = ("name", re.compile("@TEST-NAME: *(.*)"), False, False, 1, -1)
# RE_GROUP = ("group", re.compile("@TEST-GROUP: *(.*)"), False, False, 1, -1)
# RE_DIAG = ("diag-in", re.compile("@TEST-DIAG: *(.*)"), False, True, 1, -1)

Commands = (RE_EXEC, )

RE_INPUT = re.compile("%INPUT")

RE_START_NEXT_TEST = re.compile("@TEST-START-NEXT")

def output(msg, nl=True):
    if nl:
        print >>sys.stderr, msg
    else:
        print >>sys.stderr, msg,

def error(msg):
    print >>sys.stderr, msg
    sys.exit(1)

def mkdir(dir):
    if not os.path.exists(dir):
        try:
            os.mkdir(dir)
        except OSError, e:
            error("cannot create directory %s: %s" % (dir, e))
        
    else:
        if not os.path.isdir(dir):
            error("path %s exists but is not a directory" % dir)
    
class Test(object):
    def __init__(self, file = None):
        self.file = file
        self.name = None
        self.number = 1
        self.group = None
        self.cmdlines = []
        self.tmpdir = None
        self.diag = None 
        self.baseline = None

        # Parse the test's content. 
    def parse(self, content):
        cmds = {}
        for line in content:
            for (tag, regexp, multiple, optional, group1, group2) in Commands:
                m = regexp.search(line)
            
                if m:
                    value = m.group(group1)
                    
                    if group2 >= 0:
                        value = (value, m.group(group2))
                
                    if not multiple:
                        if tag in cmds:
                            error("%s: %d defined multiple times." % (test, tag))
                        
                        cmds[tag] = value
                    
                    else:
                        try:
                            cmds[tag] += [value]
                        except KeyError:
                            cmds[tag] = [value]
                            
        # Make sure all non-optional commands are there.
        for (tag, regexp, multiple, optional, group1, group2) in Commands:
            if not optional and not tag in cmds:
                error("%s: mandatory %s command not found." % (self.file, tag))

        # self.name = cmds["name"]
        # self.group = cmds["group"]
        # self.diagin = cmds["diag-in"] if "diag-in" in cmds else None

        (name, ext) = os.path.splitext(self.file)
        
        self.name = name.replace("/", ".")
        while self.name.startswith("."):
            self.name = self.name[1:]
        
        self.group = os.path.dirname(self.file).replace("/", ".")
        while self.group.startswith("."):
            self.group = self.group[1:]
        
        self.content = content
        self.cmdlines = [(cmd.strip(), success!="-FAIL") for (cmd, success) in cmds["exec"]]
        
    # Copies all control information over t a new Test but replaces test content
    # with a new one.
    def clone(self, content):
        clone = Test()
        clone.file = self.file
        clone.number = self.number + 1
        clone.name = self.name 
        clone.group = self.group
#       clone.diagin = self.diagin
        clone.cmdlines = self.cmdlines
        
        clone.content = content
        return clone        
        
    def run(self):
        if self.number > 1:
            self.name = "%s-%d" % (self.name, self.number)
            
        output("%s ..." % self.name, nl=Options.verbose)
            
        self.tmpdir = os.path.abspath(os.path.join(TmpDir, self.name))
        self.diag = os.path.join(self.tmpdir, ".diag")
        self.baseline = os.path.abspath(os.path.join(BaselineDir, self.name))
        self.diagmsgs = []
        
        self.rmTmp()
        mkdir(self.baseline)        
        mkdir(self.tmpdir)        
        os.chdir(self.tmpdir)
        
        self.localfile = os.path.join(self.tmpdir, os.path.basename(self.file))
        
        content = open(self.localfile, "w")
        for line in self.content:
            print >>content, line,
        content.close()
        
        self.log = open(os.path.join(self.tmpdir, ".log"), "w")
        self.stdout = open(os.path.join(self.tmpdir, ".stdout"), "w")
        self.stderr = open(os.path.join(self.tmpdir, ".stderr"), "w")
        
        for cmd in self.cmdlines:
            
            if Options.verbose:
                output("  > %s" % cmd[0])
            
            if not self.execute(cmd):
                if Options.verbose:
                    output("... %s failed" % self.name)
                else:
                    output("failed")
                    
                if Options.diag or Options.diagall:
                    self.showDiag()
                break
        else:
            if Options.verbose:
                    output("... %s ok" % self.name)
            else:
                output("ok")
                
            if Options.diagall:
                self.showDiag()
                
            self.rmTmp()
        
        try:
            # Try removing the baseline directory. If it works, it's empty, i.e., no baseline was created.
            os.rmdir(self.baseline)
        except OSError, e:
            pass
        
    def execute(self, cmd):
        (cmdline, expect_success) = cmd
        
        # Replace special names. 
        cmdline = RE_INPUT.sub(self.localfile, cmdline)
        print >>self.log, cmdline, "(expect %s)" % ("success" if expect_success else "failure")
        
        env = self.prepareEnv()
        
        try:
            subprocess.check_call(cmdline, shell=True, env=env, stderr=self.stderr, stdout=self.stdout)
        except subprocess.CalledProcessError, e:
            
            if expect_success:
                self.diagmsgs += ["'%s' failed unexpectedly (exit code %s)" % (cmdline, e.returncode)]
                return False
            
            else:
                return True

        if not expect_success:
            self.diagmsgs += ["'%s' succeeded unexpectedly (exit code 0)" % cmdline]
            return False
        
        return True
            
    def rmTmp(self):
        os.chdir(TmpDir)
        
        try:
            if os.path.isfile(self.tmpdir):
                os.remove(self.tmpdir)
            
            if os.path.isdir(self.tmpdir):
                subprocess.call("rm -rf %s" % self.tmpdir, shell=True)
            
        except OSError, e:
            error("cannot remove tmp directory %s: %s" % (self.tmpdir, e))

    # Prepares the environment for the child processes.
    def prepareEnv(self):
        env = copy.deepcopy(os.environ)
        
        # Add the directory where this executable is located to PATH.
        addpath = BinDir
        oldpath = os.environ["PATH"]
        env["PATH"] = "%s:%s" % (oldpath, addpath) if oldpath else addpath

        env["TEST_BASELINE"] = self.baseline
        env["TEST_DIAGNOSTICS"] = self.diag
        env["TEST_MODE"] = Options.mode.upper()
        
        return env
    
    def showDiag(self):
        for line in self.diagmsgs:
            output("  % " + line)

        for file in (self.diag, ".stderr"):
            if not file:
                continue
            
            if os.path.isfile(file):
                output("  % cat " + os.path.basename(file))
                for line in open(file):
                    output("  " + line.strip())
                output("")	
        
        if Options.wait:
            output("<Enter> ...")
            try:
                sys.stdin.readline()
            except KeyboardInterrupt:
                sys.exit(1)
            
# Walk the given directory and return all test files.    
def findTests(paths):    
    tests = []
    
    for path in paths:
        if os.path.isfile(path):
            tests += readTestFile(path)
        
        elif os.path.isdir(path):
            for (dirpath, dirnames, filenames) in os.walk(path):
                for file in filenames:
                    tests += readTestFile(os.path.join(dirpath, file))

                # Don't recurse into these. 
                for skip in (".svn", "CVS", ".tmp", ".baseline"):
                    if skip in dirnames:
                        dirnames.remove(skip)
                        
        else:
            error("cannot read %s" % path)

    return tests

# Read the given test file and instantiate one or more tests from it.
def readTestFile(filename):

    def newTest(content, previous):
        if not previous:
            t = Test(filename)
            t.parse(content)
            return t
        else:
            return previous.clone(content)
    
    try:
        file = open(filename)
    except IOError, e:
        error("cannot read test file: %s" % e)

    tests = []
    content = []
    previous = None
        
    for line in file:
        m = RE_START_NEXT_TEST.search(line)

        if not m:
            content += [line]
            continue

        t = newTest(content, previous)
        tests += [t]
        
        previous = t
        content = []

    tests += [newTest(content, previous)]
    
    return tests
    
#    tests = []
#
#    for dir in dirs:
#        if not os.path.isdir(dir):
#            error("%s is not a directory" % dir)
#            
#        try:
#            def addNames(tests, dir, names):
#                tests += [Test(os.path.abspath(fn)) for fn in fnmatch.filter(names, Glob)]
#            
#            os.path.walk(dir, addNames, tests)
#        
#        except IOError, e:
#            error("cannot traverse directory %s" % dir)
#
#    return tests

### Main

optparser = optparse.OptionParser(usage="%prog [options] <directorys>", version=Version)
optparser.add_option("-U", "--update-baseline", action="store_const", dest="mode", const="UPDATE", default="TEST",
                     help="create a new baseline from the tests' output")
optparser.add_option("-d", "--diagnostics", action="store_true", dest="diag", default=False,
                     help="show diagnostic output for failed tests")
optparser.add_option("-D", "--diagnostics-all", action="store_true", dest="diagall", default=False,
                     help="show diagnostic output for ALL tests")
optparser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False,
                     help="show commands as they are executed")
optparser.add_option("-w", "--wait", action="store_true", dest="wait", default=False,
                     help="wait for <enter> after each failed (with -d) or all (with -D) tests")

(Options, args) = optparser.parse_args()

if len(args) < 1:
    optparser.error("wrong number of arguments")

tests = findTests(args)

if not tests:
    error("no tests")

TmpDir = os.path.abspath(TmpDir)
BaselineDir = os.path.abspath(BaselineDir)
BinDir = os.path.abspath(os.path.dirname(sys.argv[0]))

mkdir(BaselineDir)
mkdir(TmpDir)

for test in tests:
    test.run()
    




