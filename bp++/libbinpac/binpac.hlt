# $Id
#
# Internal BinPAC++ code supporting the code generator.

module BinPAC

type ParseSuccess = exception<string>
type ParseError = exception<string>
type UnitAlreadyConnected = exception<>
type FilterError = exception<string>
type FilterUnsupported = exception<string>

type Parser = struct {
    string name,                  # Short descriptive name.
    string description,           # Longer textual description.
    ref<list<string>> mime_types, # MIME types handled by this parser.
    caddr parse_func,             # The C function performing the parsing.
    caddr resume_func,            # The C function resuming parsing after a yield.
    caddr parse_func_sink,        # The C function performing the parsing for a sink.
    caddr resume_func_sink,       # The C function resuming sink parsing after a yield.
    caddr new_func                # The C function to create a new instance (may be null).
}

# Registers a parser with the HILTI runtime. Note that this function is not
# thread-safe and must only be called during initialization before any threads
# have been started.
declare "C-HILTI" void register_parser(ref<Parser> parser)

# Runs a module's init function passed in with it's C stub.
# (This is only needed because we can't call the stub (easily) from C.
declare "C" void call_init_func(caddr func)

# Support functions for sinks.
type Sink = struct {
    # We leave this empty here as we access this struct only from C.
    # See sink.c for it's definition.
}

declare "C-HILTI" ref<Sink> sink_new()
declare "C-HILTI" void sink_connect(ref<Sink> sink, any pobj, ref<Parser> parser)
declare "C-HILTI" void sink_disconnect(ref<Sink> sink, any pobj)
declare "C-HILTI" void sink_write(ref<Sink> sink, ref<bytes> data)
declare "C-HILTI" void sink_close(ref<Sink> sink)
declare "C-HILTI" void sink_filter(ref<Sink> sink, ref<ParseFilter> filter)

# Support functions for filters.
type ParseFilter = struct {
    # We leave this empty here as we access this struct only from C.
    # See filter.c for it's definition.
}

# Available filter types.
type Filter = enum {
    BASE64 = 1,  # MIME base64 decoding.
    GZIP = 2     # gzipd decompression.
}

declare "C-HILTI" ref<ParseFilter> filter_new(BinPAC::Filter ftype)
declare "C-HILTI" ref<ParseFilter> filter_add(ref<ParseFilter> head, ref<ParseFilter> add)
declare "C-HILTI" ref<bytes> filter_decode(ref<ParseFilter> filter, ref<bytes> data)
declare "C-HILTI" void filter_close(ref<ParseFilter> filter)

declare "C-HILTI" void mime_connect_by_bytes(ref<Sink> sink, ref<bytes> mtype)
declare "C-HILTI" void mime_connect_by_string(ref<Sink> sink, string mtype)

# Debugging.
declare "C-HILTI" void enable_debugging(bool enabled)
declare "C-HILTI" bool debugging_enabled()
declare "C-HILTI" void debug_print_ptr(string tag, any ptr)

# Matches a regexp against a bytes object and returns a given match group.
# If not found, an empty bytes object is returned.
ref<bytes> bytes_match(ref<bytes> b, ref<regexp> re, int<64> group = 0) {
    local ref<vector<tuple<iterator<bytes>,iterator<bytes>>>> results
    local iterator<bytes> i1
    local iterator<bytes> i2
    local tuple<iterator<bytes>, iterator<bytes>> range
    local tuple<int32, tuple<iterator<bytes>,iterator<bytes>>> span
    local bool cond
    local int<64> len

    i1 = begin b
    i2 = end b

    cond = equal group 0
    if.else cond @do_span @do_groups

@do_span:
    span = regexp.span re i1 i2
    range = tuple.index span 1
    jump @done

@do_groups:
    results = regexp.groups re i1 i2

    len = vector.size results
    cond = int.ult group len
    if.else cond @found @notfound

@notfound:
    i1 = i2
    jump @finish

@found:
    range = vector.get results group
    jump @done

@done:
    i1 = tuple.index range 0
    i2 = tuple.index range 1
    jump @finish

@finish:
    b = bytes.sub i1 i2

    return.result b
}

export bytes_match
