
module http

import hilti
import binpac
import binpacintern

type DeliveryMode = enum { Chunked, EndOfData, Length, Multipart }

int<64> dec_to_int_1(ref<bytes> b) {
    local int<64> __result

@__b6:
    __result = call hilti::bytes_to_int (b, 10)
    return.result __result
    }

int<64> hex_to_int_1(ref<bytes> b) {
    local int<64> __result

@__b5:
    __result = call hilti::bytes_to_int (b, 16)
    return.result __result
    }



global ref<regexp<&nosub>> http_body_literal_9 = /[^\r\n]*\r?\n{#9}/

type http_body_object = struct {
    ref<bytes> data,
    ref<http_chunk_object> Chunk,
    int<64> length
}

ref<http_body_object> http_body_parse(iterator<bytes> __cur, int<8> __flags, ref<http_message_object> msg, DeliveryMode delivery_mode) {
    local int<32> __lahead
    local iterator<bytes> __lahstart
    local ref<http_body_object> __pobj
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult2

@__b33:
    __lahead = assign 0
    __pobj = new http_body_object
    hook.run hook_on_Body___ctor (__pobj, msg, delivery_mode)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'switch' with flags %d" (__flags)
    debug.msg "binpac" "Body" ()
    debug.push_indent

    # Parsing non-terminal start_Body
    __presult2 = call http_body_sequence_start_body (__cur, __pobj, __lahead, __lahstart, __flags, msg, delivery_mode)
    __cur = tuple.index __presult2 0
    __lahead = tuple.index __presult2 1
    __lahstart = tuple.index __presult2 2
    debug.msg "binpac-verbose" "end start-sym sequence 'switch'" ()
    debug.pop_indent
    return.result __pobj
    }

export http_body_parse

tuple<iterator<bytes>,int<32>,iterator<bytes>> http_body_sequence_start_body(iterator<bytes> __cur, ref<http_body_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg, DeliveryMode delivery_mode) {
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str
    local ref<binpac::ParseError> excpt

@__b34:
    debug.msg "binpac-verbose" "bgn switch '( Switch| T22 || T25 || T26 || T27 )'" ()

    # Parse function for production 'switch'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing switch switch
    switch delivery_mode @default ((DeliveryMode::Chunked, @case_0), (DeliveryMode::Multipart, @case_1), (DeliveryMode::Length, @case_2), (DeliveryMode::EndOfData, @case_3))

@case_0:
    # Case:  enum { Chunked, EndOfData, Length, Multipart } Chunked
    debug.msg "binpac-verbose" "bgn sequence 'T20; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T22
    __presult = call http_body_sequence_t22 (__cur, __self, __lahead, __lahstart, __flags, msg, delivery_mode)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T20; <epsilon>'" ()
    jump @cont

@case_1:
    # Case:  enum { Chunked, EndOfData, Length, Multipart } Multipart
    debug.msg "binpac-verbose" "bgn sequence 'T23; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T25
    __presult = call http_body_sequence_t25 (__cur, __self, __lahead, __lahstart, __flags, msg, delivery_mode)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T23; <epsilon>'" ()
    jump @cont

@case_2:
    # Case:  enum { Chunked, EndOfData, Length, Multipart } Length
    debug.msg "binpac-verbose" "bgn sequence 'type(bytes); <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T26
    __presult = call http_body_sequence_t26 (__cur, __self, __lahead, __lahstart, __flags, msg, delivery_mode)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'type(bytes); <epsilon>'" ()
    jump @cont

@case_3:
    # Case:  enum { Chunked, EndOfData, Length, Multipart } EndOfData
    debug.msg "binpac-verbose" "bgn sequence 'type(bytes); <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T27
    __presult = call http_body_sequence_t27 (__cur, __self, __lahead, __lahstart, __flags, msg, delivery_mode)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'type(bytes); <epsilon>'" ()
    jump @cont

@default:
    excpt = new binpac::ParseError "unexpected switch case"
    exception.throw excpt
    jump @cont

@cont:
    debug.msg "binpac-verbose" "end switch '( Switch| T22 || T25 || T26 || T27 )'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_body_sequence_t20(iterator<bytes> __cur, ref<http_body_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg, DeliveryMode delivery_mode) {
    local ref<http_chunk_object> __cobj_Chunk
    local bool __hookrc = True
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b36:
    debug.msg "binpac-verbose" "bgn childgrammar 'start_Chunk | T29 | T28 | T32 | T30 | T31 [=: Chunk]'" ()

    # Parse function for production 'T19; T21'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing child grammar Chunk
    __cobj_Chunk = new http_chunk_object
    hook.run hook_on_Chunk___ctor (__cobj_Chunk)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T28; T29; T30; T32' with flags %d" (__flags)
    debug.msg "binpac" "Chunk" ()
    debug.push_indent

    # Parsing non-terminal start_Chunk
    __presult = call http_chunk_sequence_start_chunk (__cur, __cobj_Chunk, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T28; T29; T30; T32'" ()
    debug.pop_indent
    struct.set __self "Chunk" __cobj_Chunk
    __cur = assign __cur
    __lahead = assign __lahead
    __lahstart = assign __lahstart
    struct.set __self "Chunk" __cobj_Chunk
    __hookrc = hook.run hook_on_Body_anon_45239760_dollardollar (__self, __cobj_Chunk, msg, delivery_mode)
    if.else __hookrc @true @cont

@true:
    jump @cont

@cont:
    debug.msg "binpac-verbose" "end childgrammar 'start_Chunk | T29 | T28 | T32 | T30 | T31 [=: Chunk]'" ()
    debug.msg "binpac-verbose" "bgn boolean '( Bool| T20 || <epsilon> )'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing boolean T21
    if.else __hookrc @if_True @if_False

@done:
    debug.msg "binpac-verbose" "end boolean '( Bool| T20 || <epsilon> )'" ()
    return.result (__cur, __lahead, __lahstart)

@if_True:
    # Branch for True
    debug.msg "binpac-verbose" "bgn sequence 'T19; T21'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T20
    __presult = call http_body_sequence_t20 (__cur, __self, __lahead, __lahstart, __flags, msg, delivery_mode)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T19; T21'" ()
    jump @done

@if_False:
    # Branch for False
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    jump @done
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_body_sequence_t22(iterator<bytes> __cur, ref<http_body_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg, DeliveryMode delivery_mode) {
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b35:
    debug.msg "binpac-verbose" "bgn sequence 'T19; T21'" ()

    # Parse function for production 'T20; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T20
    __presult = call http_body_sequence_t20 (__cur, __self, __lahead, __lahstart, __flags, msg, delivery_mode)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T19; T21'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Body_anon_45239760_1 (__self, msg, delivery_mode)
    hook.run hook_on_Body_anon_45239760 (__self, msg, delivery_mode)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_body_sequence_t23(iterator<bytes> __cur, ref<http_body_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg, DeliveryMode delivery_mode) {
    local bool __cond
    local bool __hookrc = True
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b47:
    debug.msg "binpac-verbose" "bgn literal '[^\\r\\n]*\\r?\\n'" ()

    # Parse function for production 'terminal_13; T24'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[^\r\n]*\r?\n'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_body_literal_9 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((9, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 9 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac-verbose" "- matched '[^\\r\\n]*\\r?\\n' to '%s'" (__token)
    __hookrc = hook.run hook_on_Body_anon_45237008_dollardollar (__self, __token, msg, delivery_mode)
    if.else __hookrc @true @cont

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont

@true:
    jump @cont

@cont:
    debug.msg "binpac-verbose" "end literal '[^\\r\\n]*\\r?\\n'" ()
    debug.msg "binpac-verbose" "bgn boolean '( Bool| T23 || <epsilon> )'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing boolean T24
    if.else __hookrc @if_True @if_False

@done:
    debug.msg "binpac-verbose" "end boolean '( Bool| T23 || <epsilon> )'" ()
    return.result (__cur, __lahead, __lahstart)

@if_True:
    # Branch for True
    debug.msg "binpac-verbose" "bgn sequence 'terminal_13; T24'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T23
    __presult = call http_body_sequence_t23 (__cur, __self, __lahead, __lahstart, __flags, msg, delivery_mode)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_13; T24'" ()
    jump @done

@if_False:
    # Branch for False
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    jump @done
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_body_sequence_t25(iterator<bytes> __cur, ref<http_body_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg, DeliveryMode delivery_mode) {
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b46:
    debug.msg "binpac-verbose" "bgn sequence 'terminal_13; T24'" ()

    # Parse function for production 'T23; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T23
    __presult = call http_body_sequence_t23 (__cur, __self, __lahead, __lahstart, __flags, msg, delivery_mode)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_13; T24'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Body_anon_45237008_2 (__self, msg, delivery_mode)
    hook.run hook_on_Body_anon_45237008 (__self, msg, delivery_mode)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_body_sequence_t26(iterator<bytes> __cur, ref<http_body_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg, DeliveryMode delivery_mode) {
    local int<64> __attr
    local bool __cond
    local bool __cont
    local iterator<bytes> __end
    local iterator<bytes> __iter
    local iterator<bytes> __next5
    local int<32> __op32
    local ref<bytes> __str
    local tuple<ref<bytes>,iterator<bytes>> __unpacked
    local ref<bytes> data
    local ref<binpac::ParseError> excpt

@__b48:
    debug.msg "binpac-verbose" "bgn variable 'type(bytes) [=: data]'" ()

    # Parse function for production 'type(bytes); <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing variable type(bytes) [=: data]
    __cond = equal __lahead 0
    debug.assert __cond
    __attr = struct.get msg "content_length"
    __op32 = int.trunc __attr
    jump @parse

@parse:
    try {
    @__b49:
        __unpacked = unpack (__cur, __end) hilti::Packed::BytesFixed __op32
    }
    catch  {
    @__b50:
        excpt = new binpac::ParseError "unpack failed"
        exception.throw excpt
    }
    catch hilti::WouldBlock {
    @__b51:
        __iter = tuple.index (__cur, __end) 0
        __cont = bytes.is_frozen __iter
        if.else __cont @error @suspend
    }
    jump @cont

@cont:
    data = tuple.index __unpacked 0
    __cur = tuple.index __unpacked 1
    debug.msg "binpac" "data = '%s'" (data)
    debug.msg "binpac-verbose" "- matched 'type(bytes) [=: data]' to '%s'" (data)
    struct.set __self "data" data
    debug.msg "binpac-verbose" "end variable 'type(bytes) [=: data]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Body_data_3 (__self, msg, delivery_mode)
    hook.run hook_on_Body_data (__self, msg, delivery_mode)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@error:
    debug.msg "binpac-verbose" "parse error, insufficient input" ()
    excpt = new binpac::ParseError "insufficient input"
    exception.throw excpt

@suspend:
    debug.msg "binpac-verbose" "out of input, yielding ..." ()
    yield
    jump @parse
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_body_sequence_t27(iterator<bytes> __cur, ref<http_body_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg, DeliveryMode delivery_mode) {
    local bool __cond
    local bool __cont
    local iterator<bytes> __end
    local bool __eod
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> data
    local ref<binpac::ParseError> excpt

@__b52:
    debug.msg "binpac-verbose" "bgn variable 'type(bytes) [=: data]'" ()

    # Parse function for production 'type(bytes); <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing variable type(bytes) [=: data]
    __cond = equal __lahead 0
    debug.assert __cond
    jump @eod_loop

@eod_loop:
    __eod = bytes.is_frozen __cur
    if.else __eod @eod_reached @eod_not_reached

@eod_reached:
    data = bytes.sub __cur __end
    debug.msg "binpac" "data = '%s'" (data)
    debug.msg "binpac-verbose" "- matched 'type(bytes) [=: data]' to '%s'" (data)
    struct.set __self "data" data
    debug.msg "binpac-verbose" "end variable 'type(bytes) [=: data]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __end 5
    __str = bytes.sub __end __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Body_data_4 (__self, msg, delivery_mode)
    hook.run hook_on_Body_data (__self, msg, delivery_mode)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__end, __lahead, __lahstart)

@eod_not_reached:
    __cont = bytes.is_frozen __cur
    if.else __cont @error @suspend

@error:
    debug.msg "binpac-verbose" "parse error, insufficient input" ()
    excpt = new binpac::ParseError "insufficient input"
    exception.throw excpt

@suspend:
    debug.msg "binpac-verbose" "out of input, yielding ..." ()
    yield
    jump @eod_loop
    }



global ref<regexp<&nosub>> http_chunk_literal_10 = /[0-9a-zA-Z]+{#10}/
global ref<regexp<&nosub>> http_chunk_literal_5 = /\r?\n{#5}/

type http_chunk_object = struct {
    ref<bytes> data,
    int<64> length
}

ref<http_chunk_object> http_chunk_parse(iterator<bytes> __cur, int<8> __flags) {
    local int<32> __lahead
    local iterator<bytes> __lahstart
    local ref<http_chunk_object> __pobj
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult2

@__b37:
    __lahead = assign 0
    __pobj = new http_chunk_object
    hook.run hook_on_Chunk___ctor (__pobj)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T28; T29; T30; T32' with flags %d" (__flags)
    debug.msg "binpac" "Chunk" ()
    debug.push_indent

    # Parsing non-terminal start_Chunk
    __presult2 = call http_chunk_sequence_start_chunk (__cur, __pobj, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult2 0
    __lahead = tuple.index __presult2 1
    __lahstart = tuple.index __presult2 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T28; T29; T30; T32'" ()
    debug.pop_indent
    return.result __pobj
    }

export http_chunk_parse

tuple<iterator<bytes>,int<32>,iterator<bytes>> http_chunk_sequence_start_chunk(iterator<bytes> __cur, ref<http_chunk_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local int<64> __attr
    local bool __bool
    local bool __equal
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b38:
    debug.msg "binpac-verbose" "bgn sequence 'terminal_16; <epsilon>'" ()

    # Parse function for production 'T28; T29; T30; T32'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T28
    __presult = call http_chunk_sequence_t28 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_16; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_17; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T29
    __presult = call http_chunk_sequence_t29 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_17; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'type(bytes); <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T30
    __presult = call http_chunk_sequence_t30 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'type(bytes); <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn boolean '( Bool| T31 || <epsilon> )'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing boolean T32
    __attr = struct.get __self "length"
    __equal = equal __attr 0
    __bool = select __equal False True
    if.else __bool @if_True @if_False

@done:
    debug.msg "binpac-verbose" "end boolean '( Bool| T31 || <epsilon> )'" ()
    return.result (__cur, __lahead, __lahstart)

@if_True:
    # Branch for True
    debug.msg "binpac-verbose" "bgn sequence 'terminal_19; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T31
    __presult = call http_chunk_sequence_t31 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_19; <epsilon>'" ()
    jump @done

@if_False:
    # Branch for False
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    jump @done
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_chunk_sequence_t28(iterator<bytes> __cur, ref<http_chunk_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local int<64> __result
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b39:
    debug.msg "binpac-verbose" "bgn literal '[0-9a-zA-Z]+ [=: length]'" ()

    # Parse function for production 'terminal_16; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[0-9a-zA-Z]+'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_chunk_literal_10 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((10, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 10 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    __result = call hex_to_int_1 (__token)
    debug.msg "binpac" "length = '%s'" (__result)
    debug.msg "binpac-verbose" "- matched '[0-9a-zA-Z]+ [=: length]' to '%s'" (__result)
    struct.set __self "length" __result
    debug.msg "binpac-verbose" "end literal '[0-9a-zA-Z]+ [=: length]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Chunk_length (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_chunk_sequence_t29(iterator<bytes> __cur, ref<http_chunk_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b40:
    debug.msg "binpac-verbose" "bgn literal '\\r?\\n'" ()

    # Parse function for production 'terminal_17; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '\r?\n'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_chunk_literal_5 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((5, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 5 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac-verbose" "- matched '\\r?\\n' to '%s'" (__token)
    debug.msg "binpac-verbose" "end literal '\\r?\\n'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Chunk_anon_45428112 (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_chunk_sequence_t30(iterator<bytes> __cur, ref<http_chunk_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local int<64> __attr
    local bool __cond
    local bool __cont
    local iterator<bytes> __end
    local iterator<bytes> __iter
    local iterator<bytes> __next5
    local int<32> __op32
    local ref<bytes> __str
    local tuple<ref<bytes>,iterator<bytes>> __unpacked
    local ref<bytes> data
    local ref<binpac::ParseError> excpt

@__b41:
    debug.msg "binpac-verbose" "bgn variable 'type(bytes) [=: data]'" ()

    # Parse function for production 'type(bytes); <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing variable type(bytes) [=: data]
    __cond = equal __lahead 0
    debug.assert __cond
    __attr = struct.get __self "length"
    __op32 = int.trunc __attr
    jump @parse

@parse:
    try {
    @__b42:
        __unpacked = unpack (__cur, __end) hilti::Packed::BytesFixed __op32
    }
    catch  {
    @__b43:
        excpt = new binpac::ParseError "unpack failed"
        exception.throw excpt
    }
    catch hilti::WouldBlock {
    @__b44:
        __iter = tuple.index (__cur, __end) 0
        __cont = bytes.is_frozen __iter
        if.else __cont @error @suspend
    }
    jump @cont

@cont:
    data = tuple.index __unpacked 0
    __cur = tuple.index __unpacked 1
    debug.msg "binpac" "data = '%s'" (data)
    debug.msg "binpac-verbose" "- matched 'type(bytes) [=: data]' to '%s'" (data)
    struct.set __self "data" data
    debug.msg "binpac-verbose" "end variable 'type(bytes) [=: data]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Chunk_data (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@error:
    debug.msg "binpac-verbose" "parse error, insufficient input" ()
    excpt = new binpac::ParseError "insufficient input"
    exception.throw excpt

@suspend:
    debug.msg "binpac-verbose" "out of input, yielding ..." ()
    yield
    jump @parse
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_chunk_sequence_t31(iterator<bytes> __cur, ref<http_chunk_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b45:
    debug.msg "binpac-verbose" "bgn literal '\\r?\\n'" ()

    # Parse function for production 'terminal_19; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '\r?\n'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_chunk_literal_5 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((5, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 5 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac-verbose" "- matched '\\r?\\n' to '%s'" (__token)
    debug.msg "binpac-verbose" "end literal '\\r?\\n'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Chunk_anon_45498576 (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }



global ref<regexp<&nosub>> http_header_literal_2 = /[ \t]+{#2}/
global ref<regexp<&nosub>> http_header_literal_5 = /\r?\n{#5}/
global ref<regexp<&nosub>> http_header_literal_6 = /[^:\r\n]+{#6}/
global ref<regexp<&nosub>> http_header_literal_7 = /:{#7}/
global ref<regexp<&nosub>> http_header_literal_8 = /[^\r\n]+{#8}/

type http_header_object = struct {
    ref<bytes> name,
    ref<bytes> content
}

ref<http_header_object> http_header_parse(iterator<bytes> __cur, int<8> __flags, ref<http_message_object> msg) {
    local int<32> __lahead
    local iterator<bytes> __lahstart
    local ref<http_header_object> __pobj
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult2

@__b23:
    __lahead = assign 0
    __pobj = new http_header_object
    hook.run hook_on_Header___ctor (__pobj, msg)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T14; T15; T16; T17; T18' with flags %d" (__flags)
    debug.msg "binpac" "Header" ()
    debug.push_indent

    # Parsing non-terminal start_Header
    __presult2 = call http_header_sequence_start_header (__cur, __pobj, __lahead, __lahstart, __flags, msg)
    __cur = tuple.index __presult2 0
    __lahead = tuple.index __presult2 1
    __lahstart = tuple.index __presult2 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T14; T15; T16; T17; T18'" ()
    debug.pop_indent
    return.result __pobj
    }

export http_header_parse

tuple<iterator<bytes>,int<32>,iterator<bytes>> http_header_sequence_start_header(iterator<bytes> __cur, ref<http_header_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg) {
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b24:
    debug.msg "binpac-verbose" "bgn sequence 'terminal_8; <epsilon>'" ()

    # Parse function for production 'T14; T15; T16; T17; T18'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T14
    __presult = call http_header_sequence_t14 (__cur, __self, __lahead, __lahstart, __flags, msg)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_8; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_9; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T15
    __presult = call http_header_sequence_t15 (__cur, __self, __lahead, __lahstart, __flags, msg)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_9; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_10; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T16
    __presult = call http_header_sequence_t16 (__cur, __self, __lahead, __lahstart, __flags, msg)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_10; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_11; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T17
    __presult = call http_header_sequence_t17 (__cur, __self, __lahead, __lahstart, __flags, msg)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_11; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_12; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T18
    __presult = call http_header_sequence_t18 (__cur, __self, __lahead, __lahstart, __flags, msg)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_12; <epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_header_sequence_t14(iterator<bytes> __cur, ref<http_header_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __result
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b25:
    debug.msg "binpac-verbose" "bgn literal '[^:\\r\\n]+ [=: name]'" ()

    # Parse function for production 'terminal_8; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[^:\r\n]+'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_header_literal_6 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((6, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 6 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    __result = call to_lower_1 (__token)
    debug.msg "binpac" "name = '%s'" (__result)
    debug.msg "binpac-verbose" "- matched '[^:\\r\\n]+ [=: name]' to '%s'" (__result)
    struct.set __self "name" __result
    debug.msg "binpac-verbose" "end literal '[^:\\r\\n]+ [=: name]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Header_name (__self, msg)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_header_sequence_t15(iterator<bytes> __cur, ref<http_header_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b26:
    debug.msg "binpac-verbose" "bgn literal ':'" ()

    # Parse function for production 'terminal_9; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal ':'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_header_literal_7 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((7, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 7 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac-verbose" "- matched ':' to '%s'" (__token)
    debug.msg "binpac-verbose" "end literal ':'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Header_anon_45241872 (__self, msg)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_header_sequence_t16(iterator<bytes> __cur, ref<http_header_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b27:
    debug.msg "binpac-verbose" "bgn literal '[ \\t]+'" ()

    # Parse function for production 'terminal_10; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[ \t]+'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_header_literal_2 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((2, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 2 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac-verbose" "- matched '[ \\t]+' to '%s'" (__token)
    debug.msg "binpac-verbose" "end literal '[ \\t]+'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Header_anon_45242192 (__self, msg)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_header_sequence_t17(iterator<bytes> __cur, ref<http_header_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b28:
    debug.msg "binpac-verbose" "bgn literal '[^\\r\\n]+ [=: content]'" ()

    # Parse function for production 'terminal_11; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[^\r\n]+'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_header_literal_8 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((8, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 8 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac" "content = '%s'" (__token)
    debug.msg "binpac-verbose" "- matched '[^\\r\\n]+ [=: content]' to '%s'" (__token)
    struct.set __self "content" __token
    debug.msg "binpac-verbose" "end literal '[^\\r\\n]+ [=: content]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Header_content (__self, msg)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_header_sequence_t18(iterator<bytes> __cur, ref<http_header_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags, ref<http_message_object> msg) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b29:
    debug.msg "binpac-verbose" "bgn literal '\\r?\\n'" ()

    # Parse function for production 'terminal_12; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '\r?\n'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_header_literal_5 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((5, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 5 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac-verbose" "- matched '\\r?\\n' to '%s'" (__token)
    debug.msg "binpac-verbose" "end literal '\\r?\\n'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Header_anon_45242832 (__self, msg)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_message_lahead_t9(iterator<bytes> __cur, ref<http_message_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local bool __not_set
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str
    local ref<binpac::ParseError> excpt

@__b30:

    # Parse function for production '( ll1| <epsilon> || T8 )'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_cont

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_message_regexp_t9 __cur
    __lahead = tuple.index __match 0
    # jump @no_lahead_cont

@no_lahead_cont:
    switch __lahead @unexpected_sym ((5, @case_0), (6, @case_1), (0, @not_found), (-1, @need_input))

@done:
    return.result (__cur, __lahead, __lahstart)

@case_0:
    # For look-ahead set {"\r?\n"}
    __cur = tuple.index __match 1
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    jump @done

@case_1:
    # For look-ahead set {"[^:\r\n]+"}
    __cur = tuple.index __match 1
    __not_set = struct.is_set __self "headers"
    __not_set = bool.not __not_set
    if.else __not_set @true @cont

@true:
    struct.set __self "headers" list<ref<http_header_object>>()
    jump @cont

@cont:
    debug.msg "binpac-verbose" "bgn sequence 'T7; T9 [=: headers]'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T8
    __not_set = struct.is_set __self "headers"
    __not_set = bool.not __not_set
    if.else __not_set @true2 @cont2

@true2:
    struct.set __self "headers" list<ref<http_header_object>>()
    jump @cont2

@cont2:
    __presult = call http_message_sequence_t8 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T7; T9 [=: headers]'" ()
    jump @done

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"
    }



global ref<regexp<&nosub>> http_message_literal_5 = /\r?\n{#5}/

type http_message_object = struct {
    ref<bytes> end_of_hdr,
    ref<list<ref<http_header_object>>> headers,
    ref<http_header_object> Header,
    ref<bytes> multipart_boundary,
    int<64> length,
    ref<bytes> name,
    ref<bytes> transfer_encoding,
    ref<bytes> content_type,
    ref<http_chunk_object> Chunk,
    int<64> content_length,
    ref<bytes> data,
    ref<bytes> content,
    DeliveryMode delivery_mode &default=DeliveryMode::EndOfData,
    ref<http_body_object> body
}

ref<http_message_object> http_message_parse(iterator<bytes> __cur, int<8> __flags) {
    local int<32> __lahead
    local iterator<bytes> __lahstart
    local ref<http_message_object> __pobj
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult2

@__b19:
    __lahead = assign 0
    __pobj = new http_message_object
    hook.run hook_on_Message___ctor (__pobj)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T43; T44; T46' with flags %d" (__flags)
    debug.msg "binpac" "Message" ()
    debug.push_indent

    # Parsing non-terminal start_Message_2
    __presult2 = call http_message_sequence_start_message_2 (__cur, __pobj, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult2 0
    __lahead = tuple.index __presult2 1
    __lahstart = tuple.index __presult2 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T43; T44; T46'" ()
    debug.pop_indent
    return.result __pobj
    }

export http_message_parse


global ref<regexp<&nosub>> http_message_regexp_t9 = /\r?\n{#5}/ | /[^:\r\n]+{#6}/

tuple<iterator<bytes>,int<32>,iterator<bytes>> http_message_sequence_start_message_2(iterator<bytes> __cur, ref<http_message_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b20:
    debug.msg "binpac-verbose" "bgn sequence 'T8; <epsilon>'" ()

    # Parse function for production 'T43; T44; T46'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T43
    __presult = call http_message_sequence_t43 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T8; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_26; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T44
    __presult = call http_message_sequence_t44 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_26; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'T45; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T46
    __presult = call http_message_sequence_t46 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T45; <epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }

tuple<iterator<bytes>,int<32>,iterator<bytes>> http_message_sequence_start_message_3(iterator<bytes> __cur, ref<http_message_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b67:
    debug.msg "binpac-verbose" "bgn sequence 'T8; <epsilon>'" ()

    # Parse function for production 'T72; T73; T75'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T72
    __presult = call http_message_sequence_t72 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T8; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_45; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T73
    __presult = call http_message_sequence_t73 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_45; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'T74; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T75
    __presult = call http_message_sequence_t75 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T74; <epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_message_sequence_t43(iterator<bytes> __cur, ref<http_message_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local iterator<bytes> __next5
    local bool __not_set
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b21:
    debug.msg "binpac-verbose" "bgn sequence 'T7; T9 [=: headers]'" ()

    # Parse function for production 'T8; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T8
    __not_set = struct.is_set __self "headers"
    __not_set = bool.not __not_set
    if.else __not_set @true @cont

@true:
    struct.set __self "headers" list<ref<http_header_object>>()
    jump @cont

@cont:
    __presult = call http_message_sequence_t8 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T7; T9 [=: headers]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Message_headers (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_message_sequence_t44(iterator<bytes> __cur, ref<http_message_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b31:
    debug.msg "binpac-verbose" "bgn literal '\\r?\\n [=: end_of_hdr]'" ()

    # Parse function for production 'terminal_26; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '\r?\n'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_message_literal_5 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((5, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 5 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac" "end_of_hdr = '%s'" (__token)
    debug.msg "binpac-verbose" "- matched '\\r?\\n [=: end_of_hdr]' to '%s'" (__token)
    struct.set __self "end_of_hdr" __token
    debug.msg "binpac-verbose" "end literal '\\r?\\n [=: end_of_hdr]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Message_end_of_hdr (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_message_sequence_t46(iterator<bytes> __cur, ref<http_message_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local DeliveryMode __attr
    local ref<http_body_object> __cobj_Body
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b32:
    debug.msg "binpac-verbose" "bgn childgrammar 'start_Chunk | T26 | T25 | T24 | T29 | T28 | switch | T27 | T20 | T21 | start_Body | T23 | T22 | T32 | T19 | T30 | T31 [=: body]'" ()

    # Parse function for production 'T45; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing child grammar Body
    __attr = struct.get __self "delivery_mode"
    __cobj_Body = new http_body_object
    hook.run hook_on_Body___ctor (__cobj_Body, __self, __attr)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'switch' with flags %d" (__flags)
    debug.msg "binpac" "Body" ()
    debug.push_indent

    # Parsing non-terminal start_Body
    __presult = call http_body_sequence_start_body (__cur, __cobj_Body, __lahead, __lahstart, __flags, __self, __attr)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end start-sym sequence 'switch'" ()
    debug.pop_indent
    struct.set __self "body" __cobj_Body
    __cur = assign __cur
    __lahead = assign __lahead
    __lahstart = assign __lahstart
    struct.set __self "body" __cobj_Body
    debug.msg "binpac-verbose" "end childgrammar 'start_Chunk | T26 | T25 | T24 | T29 | T28 | switch | T27 | T20 | T21 | start_Body | T23 | T22 | T32 | T19 | T30 | T31 [=: body]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Message_body (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_message_sequence_t72(iterator<bytes> __cur, ref<http_message_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local iterator<bytes> __next5
    local bool __not_set
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b68:
    debug.msg "binpac-verbose" "bgn sequence 'T7; T9 [=: headers]'" ()

    # Parse function for production 'T8; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T8
    __not_set = struct.is_set __self "headers"
    __not_set = bool.not __not_set
    if.else __not_set @true @cont

@true:
    struct.set __self "headers" list<ref<http_header_object>>()
    jump @cont

@cont:
    __presult = call http_message_sequence_t8 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T7; T9 [=: headers]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Message_headers (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_message_sequence_t73(iterator<bytes> __cur, ref<http_message_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b69:
    debug.msg "binpac-verbose" "bgn literal '\\r?\\n [=: end_of_hdr]'" ()

    # Parse function for production 'terminal_45; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '\r?\n'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_message_literal_5 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((5, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 5 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac" "end_of_hdr = '%s'" (__token)
    debug.msg "binpac-verbose" "- matched '\\r?\\n [=: end_of_hdr]' to '%s'" (__token)
    struct.set __self "end_of_hdr" __token
    debug.msg "binpac-verbose" "end literal '\\r?\\n [=: end_of_hdr]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Message_end_of_hdr (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_message_sequence_t75(iterator<bytes> __cur, ref<http_message_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local DeliveryMode __attr
    local ref<http_body_object> __cobj_Body
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b70:
    debug.msg "binpac-verbose" "bgn childgrammar 'start_Chunk | T26 | T25 | T24 | T29 | T28 | switch | T27 | T20 | T21 | start_Body | T23 | T22 | T32 | T19 | T30 | T31 [=: body]'" ()

    # Parse function for production 'T74; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing child grammar Body
    __attr = struct.get __self "delivery_mode"
    __cobj_Body = new http_body_object
    hook.run hook_on_Body___ctor (__cobj_Body, __self, __attr)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'switch' with flags %d" (__flags)
    debug.msg "binpac" "Body" ()
    debug.push_indent

    # Parsing non-terminal start_Body
    __presult = call http_body_sequence_start_body (__cur, __cobj_Body, __lahead, __lahstart, __flags, __self, __attr)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end start-sym sequence 'switch'" ()
    debug.pop_indent
    struct.set __self "body" __cobj_Body
    __cur = assign __cur
    __lahead = assign __lahead
    __lahstart = assign __lahstart
    struct.set __self "body" __cobj_Body
    debug.msg "binpac-verbose" "end childgrammar 'start_Chunk | T26 | T25 | T24 | T29 | T28 | switch | T27 | T20 | T21 | start_Body | T23 | T22 | T32 | T19 | T30 | T31 [=: body]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Message_body (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_message_sequence_t8(iterator<bytes> __cur, ref<http_message_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local ref<http_header_object> __cobj_Header
    local bool __hookrc = True
    local iterator<bytes> __next5
    local bool __not_set
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b22:

    # Parse function for production 'T7; T9 [=: headers]'
    __not_set = struct.is_set __self "headers"
    __not_set = bool.not __not_set
    if.else __not_set @true @cont

@true:
    struct.set __self "headers" list<ref<http_header_object>>()
    jump @cont

@cont:
    debug.msg "binpac-verbose" "bgn childgrammar 'start_Header | T14 | T15 | T16 | T17 | T18 [=: Header]'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing child grammar Header
    __cobj_Header = new http_header_object
    hook.run hook_on_Header___ctor (__cobj_Header, __self)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T14; T15; T16; T17; T18' with flags %d" (__flags)
    debug.msg "binpac" "Header" ()
    debug.push_indent

    # Parsing non-terminal start_Header
    __presult = call http_header_sequence_start_header (__cur, __cobj_Header, __lahead, __lahstart, __flags, __self)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T14; T15; T16; T17; T18'" ()
    debug.pop_indent
    struct.set __self "Header" __cobj_Header
    __cur = assign __cur
    __lahead = assign __lahead
    __lahstart = assign __lahstart
    struct.set __self "Header" __cobj_Header
    __hookrc = hook.run hook_on_Message_headers_dollardollar (__self, __cobj_Header)
    if.else __hookrc @true2 @cont2

@true2:
    jump @cont2

@cont2:
    debug.msg "binpac-verbose" "end childgrammar 'start_Header | T14 | T15 | T16 | T17 | T18 [=: Header]'" ()
    debug.msg "binpac-verbose" "bgn lookahead '( ll1| <epsilon> || T8 )'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T9
    __presult = call http_message_lahead_t9 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end lookahead '( ll1| <epsilon> || T8 )'" ()
    return.result (__cur, __lahead, __lahstart)
    }


init void http_reply_init() {
    local caddr f
    local tuple<caddr,caddr> funcs
    local ref<binpacintern::Parser> parser

@__b71:
    parser = new binpacintern::Parser
    funcs = caddr.function http_reply_parse
    struct.set parser "name" "HTTP::Reply"
    struct.set parser "description" "(No description)"
    f = tuple.index funcs 0
    struct.set parser "parse_func" f
    f = tuple.index funcs 1
    struct.set parser "resume_func" f
    call binpacintern::register_parser (parser)
    return.void
    }



type http_reply_object = struct {
    ref<http_message_object> message,
    ref<list<ref<http_header_object>>> headers,
    ref<http_header_object> Header,
    ref<bytes> end_of_hdr,
    ref<bytes> name,
    int<64> length,
    ref<http_chunk_object> Chunk,
    ref<http_replyline_object> reply,
    ref<bytes> status,
    ref<bytes> reason,
    ref<bytes> version,
    ref<bytes> data,
    ref<bytes> content,
    ref<http_body_object> body
}

ref<http_reply_object> http_reply_parse(iterator<bytes> __cur, int<8> __flags) {
    local int<32> __lahead
    local iterator<bytes> __lahstart
    local ref<http_reply_object> __pobj
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult2

@__b55:
    __lahead = assign 0
    __pobj = new http_reply_object
    hook.run hook_on_Reply___ctor (__pobj)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T63; T65' with flags %d" (__flags)
    debug.msg "binpac" "Reply" ()
    debug.push_indent

    # Parsing non-terminal start_Reply
    __presult2 = call http_reply_sequence_start_reply (__cur, __pobj, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult2 0
    __lahead = tuple.index __presult2 1
    __lahstart = tuple.index __presult2 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T63; T65'" ()
    debug.pop_indent
    return.result __pobj
    }

export http_reply_parse

tuple<iterator<bytes>,int<32>,iterator<bytes>> http_reply_sequence_start_reply(iterator<bytes> __cur, ref<http_reply_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b56:
    debug.msg "binpac-verbose" "bgn sequence 'T62; <epsilon>'" ()

    # Parse function for production 'T63; T65'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T63
    __presult = call http_reply_sequence_t63 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T62; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'T64; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T65
    __presult = call http_reply_sequence_t65 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T64; <epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_reply_sequence_t63(iterator<bytes> __cur, ref<http_reply_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local ref<http_replyline_object> __cobj_ReplyLine
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b57:
    debug.msg "binpac-verbose" "bgn childgrammar 'start_ReplyLine_2 | T69 | T68 | T67 | T66 | T70 | T71 [=: reply]'" ()

    # Parse function for production 'T62; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing child grammar ReplyLine
    __cobj_ReplyLine = new http_replyline_object
    hook.run hook_on_ReplyLine___ctor (__cobj_ReplyLine)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T66; T67; T68; T69; T70; T71' with flags %d" (__flags)
    debug.msg "binpac" "ReplyLine" ()
    debug.push_indent

    # Parsing non-terminal start_ReplyLine_2
    __presult = call http_replyline_sequence_start_replyline_2 (__cur, __cobj_ReplyLine, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T66; T67; T68; T69; T70; T71'" ()
    debug.pop_indent
    struct.set __self "reply" __cobj_ReplyLine
    __cur = assign __cur
    __lahead = assign __lahead
    __lahstart = assign __lahstart
    struct.set __self "reply" __cobj_ReplyLine
    debug.msg "binpac-verbose" "end childgrammar 'start_ReplyLine_2 | T69 | T68 | T67 | T66 | T70 | T71 [=: reply]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Reply_reply (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_reply_sequence_t65(iterator<bytes> __cur, ref<http_reply_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local ref<http_message_object> __cobj_Message
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b66:
    debug.msg "binpac-verbose" "bgn childgrammar 'T14 | T73 | T16 | T17 | T74 | T75 | T18 | T19 | T30 | T31 | start_Chunk | T32 | T8 | T9 | T7 | T29 | T28 | T21 | T20 | T23 | T22 | T25 | T24 | T27 | T26 | T72 | start_Message_3 | T15 | start_Header | switch | start_Body [=: message]'" ()

    # Parse function for production 'T64; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing child grammar Message
    __cobj_Message = new http_message_object
    hook.run hook_on_Message___ctor (__cobj_Message)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T72; T73; T75' with flags %d" (__flags)
    debug.msg "binpac" "Message" ()
    debug.push_indent

    # Parsing non-terminal start_Message_3
    __presult = call http_message_sequence_start_message_3 (__cur, __cobj_Message, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T72; T73; T75'" ()
    debug.pop_indent
    struct.set __self "message" __cobj_Message
    __cur = assign __cur
    __lahead = assign __lahead
    __lahstart = assign __lahstart
    struct.set __self "message" __cobj_Message
    debug.msg "binpac-verbose" "end childgrammar 'T14 | T73 | T16 | T17 | T74 | T75 | T18 | T19 | T30 | T31 | start_Chunk | T32 | T8 | T9 | T7 | T29 | T28 | T21 | T20 | T23 | T22 | T25 | T24 | T27 | T26 | T72 | start_Message_3 | T15 | start_Header | switch | start_Body [=: message]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Reply_message (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }



global ref<regexp<&nosub>> http_replyline_literal_1 = /HTTP\/[0-9]\.[0-9]{#1}/
global ref<regexp<&nosub>> http_replyline_literal_2 = /[ \t]+{#2}/
global ref<regexp<&nosub>> http_replyline_literal_3 = /[0-9]+{#3}/
global ref<regexp<&nosub>> http_replyline_literal_4 = /[^\r\n]*{#4}/
global ref<regexp<&nosub>> http_replyline_literal_5 = /\r?\n{#5}/

type http_replyline_object = struct {
    ref<bytes> version,
    ref<bytes> status,
    ref<bytes> reason
}

ref<http_replyline_object> http_replyline_parse(iterator<bytes> __cur, int<8> __flags) {
    local int<32> __lahead
    local iterator<bytes> __lahstart
    local ref<http_replyline_object> __pobj
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult2

@__b58:
    __lahead = assign 0
    __pobj = new http_replyline_object
    hook.run hook_on_ReplyLine___ctor (__pobj)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T66; T67; T68; T69; T70; T71' with flags %d" (__flags)
    debug.msg "binpac" "ReplyLine" ()
    debug.push_indent

    # Parsing non-terminal start_ReplyLine_2
    __presult2 = call http_replyline_sequence_start_replyline_2 (__cur, __pobj, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult2 0
    __lahead = tuple.index __presult2 1
    __lahstart = tuple.index __presult2 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T66; T67; T68; T69; T70; T71'" ()
    debug.pop_indent
    return.result __pobj
    }

export http_replyline_parse

tuple<iterator<bytes>,int<32>,iterator<bytes>> http_replyline_sequence_start_replyline_2(iterator<bytes> __cur, ref<http_replyline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b59:
    debug.msg "binpac-verbose" "bgn sequence 'terminal_39; <epsilon>'" ()

    # Parse function for production 'T66; T67; T68; T69; T70; T71'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T66
    __presult = call http_replyline_sequence_t66 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_39; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_40; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T67
    __presult = call http_replyline_sequence_t67 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_40; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_41; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T68
    __presult = call http_replyline_sequence_t68 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_41; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_42; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T69
    __presult = call http_replyline_sequence_t69 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_42; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_43; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T70
    __presult = call http_replyline_sequence_t70 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_43; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_44; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T71
    __presult = call http_replyline_sequence_t71 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_44; <epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_replyline_sequence_t66(iterator<bytes> __cur, ref<http_replyline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b60:
    debug.msg "binpac-verbose" "bgn literal 'HTTP\\/[0-9]\\.[0-9] [=: version]'" ()

    # Parse function for production 'terminal_39; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal 'HTTP\/[0-9]\.[0-9]'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_replyline_literal_1 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((1, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 1 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac" "version = '%s'" (__token)
    debug.msg "binpac-verbose" "- matched 'HTTP\\/[0-9]\\.[0-9] [=: version]' to '%s'" (__token)
    struct.set __self "version" __token
    debug.msg "binpac-verbose" "end literal 'HTTP\\/[0-9]\\.[0-9] [=: version]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_ReplyLine_version (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_replyline_sequence_t67(iterator<bytes> __cur, ref<http_replyline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b61:
    debug.msg "binpac-verbose" "bgn literal '[ \\t]+'" ()

    # Parse function for production 'terminal_40; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[ \t]+'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_replyline_literal_2 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((2, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 2 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac-verbose" "- matched '[ \\t]+' to '%s'" (__token)
    debug.msg "binpac-verbose" "end literal '[ \\t]+'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_ReplyLine_anon_45206224 (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_replyline_sequence_t68(iterator<bytes> __cur, ref<http_replyline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b62:
    debug.msg "binpac-verbose" "bgn literal '[0-9]+ [=: status]'" ()

    # Parse function for production 'terminal_41; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[0-9]+'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_replyline_literal_3 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((3, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 3 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac" "status = '%s'" (__token)
    debug.msg "binpac-verbose" "- matched '[0-9]+ [=: status]' to '%s'" (__token)
    struct.set __self "status" __token
    debug.msg "binpac-verbose" "end literal '[0-9]+ [=: status]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_ReplyLine_status (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_replyline_sequence_t69(iterator<bytes> __cur, ref<http_replyline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b63:
    debug.msg "binpac-verbose" "bgn literal '[ \\t]+'" ()

    # Parse function for production 'terminal_42; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[ \t]+'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_replyline_literal_2 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((2, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 2 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac-verbose" "- matched '[ \\t]+' to '%s'" (__token)
    debug.msg "binpac-verbose" "end literal '[ \\t]+'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_ReplyLine_anon_45206864 (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_replyline_sequence_t70(iterator<bytes> __cur, ref<http_replyline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b64:
    debug.msg "binpac-verbose" "bgn literal '[^\\r\\n]* [=: reason]'" ()

    # Parse function for production 'terminal_43; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[^\r\n]*'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_replyline_literal_4 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((4, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 4 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac" "reason = '%s'" (__token)
    debug.msg "binpac-verbose" "- matched '[^\\r\\n]* [=: reason]' to '%s'" (__token)
    struct.set __self "reason" __token
    debug.msg "binpac-verbose" "end literal '[^\\r\\n]* [=: reason]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_ReplyLine_reason (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_replyline_sequence_t71(iterator<bytes> __cur, ref<http_replyline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b65:
    debug.msg "binpac-verbose" "bgn literal '\\r?\\n'" ()

    # Parse function for production 'terminal_44; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '\r?\n'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_replyline_literal_5 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((5, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 5 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac-verbose" "- matched '\\r?\\n' to '%s'" (__token)
    debug.msg "binpac-verbose" "end literal '\\r?\\n'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_ReplyLine_anon_45207504 (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


init void http_request_init() {
    local caddr f
    local tuple<caddr,caddr> funcs
    local ref<binpacintern::Parser> parser

@__b53:
    parser = new binpacintern::Parser
    funcs = caddr.function http_request_parse
    struct.set parser "name" "HTTP::Request"
    struct.set parser "description" "(No description)"
    f = tuple.index funcs 0
    struct.set parser "parse_func" f
    f = tuple.index funcs 1
    struct.set parser "resume_func" f
    call binpacintern::register_parser (parser)
    return.void
    }



type http_request_object = struct {
    ref<bytes> method,
    ref<http_message_object> message,
    ref<list<ref<http_header_object>>> headers,
    ref<http_header_object> Header,
    ref<bytes> end_of_hdr,
    ref<bytes> name,
    int<64> length,
    ref<http_chunk_object> Chunk,
    ref<bytes> uri,
    ref<bytes> version,
    ref<bytes> data,
    ref<bytes> content,
    ref<http_body_object> body,
    ref<http_requestline_object> request
}

ref<http_request_object> http_request_parse(iterator<bytes> __cur, int<8> __flags) {
    local int<32> __lahead
    local iterator<bytes> __lahstart
    local ref<http_request_object> __pobj
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult2

@__b7:
    __lahead = assign 0
    __pobj = new http_request_object
    hook.run hook_on_Request___ctor (__pobj)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T34; T36' with flags %d" (__flags)
    debug.msg "binpac" "Request" ()
    debug.push_indent

    # Parsing non-terminal start_Request
    __presult2 = call http_request_sequence_start_request (__cur, __pobj, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult2 0
    __lahead = tuple.index __presult2 1
    __lahstart = tuple.index __presult2 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T34; T36'" ()
    debug.pop_indent
    return.result __pobj
    }

export http_request_parse

tuple<iterator<bytes>,int<32>,iterator<bytes>> http_request_sequence_start_request(iterator<bytes> __cur, ref<http_request_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b8:
    debug.msg "binpac-verbose" "bgn sequence 'T33; <epsilon>'" ()

    # Parse function for production 'T34; T36'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T34
    __presult = call http_request_sequence_t34 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T33; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'T35; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T36
    __presult = call http_request_sequence_t36 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'T35; <epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_request_sequence_t34(iterator<bytes> __cur, ref<http_request_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local ref<http_requestline_object> __cobj_RequestLine
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b9:
    debug.msg "binpac-verbose" "bgn childgrammar 'T42 | T41 | T40 | start_RequestLine | T38 | T39 | T37 [=: request]'" ()

    # Parse function for production 'T33; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing child grammar RequestLine
    __cobj_RequestLine = new http_requestline_object
    hook.run hook_on_RequestLine___ctor (__cobj_RequestLine)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T37; T38; T39; T40; T41; T42' with flags %d" (__flags)
    debug.msg "binpac" "RequestLine" ()
    debug.push_indent

    # Parsing non-terminal start_RequestLine
    __presult = call http_requestline_sequence_start_requestline (__cur, __cobj_RequestLine, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T37; T38; T39; T40; T41; T42'" ()
    debug.pop_indent
    struct.set __self "request" __cobj_RequestLine
    __cur = assign __cur
    __lahead = assign __lahead
    __lahstart = assign __lahstart
    struct.set __self "request" __cobj_RequestLine
    debug.msg "binpac-verbose" "end childgrammar 'T42 | T41 | T40 | start_RequestLine | T38 | T39 | T37 [=: request]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Request_request (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_request_sequence_t36(iterator<bytes> __cur, ref<http_request_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local ref<http_message_object> __cobj_Message
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b18:
    debug.msg "binpac-verbose" "bgn childgrammar 'T14 | T15 | T16 | T17 | start_Body | T18 | T19 | T30 | T31 | start_Chunk | T32 | T8 | T9 | T7 | T29 | T28 | T21 | T20 | T23 | T22 | T25 | T24 | T27 | T26 | start_Message_2 | T43 | T46 | T45 | T44 | start_Header | switch [=: message]'" ()

    # Parse function for production 'T35; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing child grammar Message
    __cobj_Message = new http_message_object
    hook.run hook_on_Message___ctor (__cobj_Message)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T43; T44; T46' with flags %d" (__flags)
    debug.msg "binpac" "Message" ()
    debug.push_indent

    # Parsing non-terminal start_Message_2
    __presult = call http_message_sequence_start_message_2 (__cur, __cobj_Message, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T43; T44; T46'" ()
    debug.pop_indent
    struct.set __self "message" __cobj_Message
    __cur = assign __cur
    __lahead = assign __lahead
    __lahstart = assign __lahstart
    struct.set __self "message" __cobj_Message
    debug.msg "binpac-verbose" "end childgrammar 'T14 | T15 | T16 | T17 | start_Body | T18 | T19 | T30 | T31 | start_Chunk | T32 | T8 | T9 | T7 | T29 | T28 | T21 | T20 | T23 | T22 | T25 | T24 | T27 | T26 | start_Message_2 | T43 | T46 | T45 | T44 | start_Header | switch [=: message]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_Request_message (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }



global ref<regexp<&nosub>> http_requestline_literal_1 = /HTTP\/[0-9]\.[0-9]{#1}/
global ref<regexp<&nosub>> http_requestline_literal_11 = /[^ \t\r\n]+{#11}/
global ref<regexp<&nosub>> http_requestline_literal_2 = /[ \t]+{#2}/
global ref<regexp<&nosub>> http_requestline_literal_5 = /\r?\n{#5}/

type http_requestline_object = struct {
    ref<bytes> method,
    ref<bytes> version,
    ref<bytes> uri
}

ref<http_requestline_object> http_requestline_parse(iterator<bytes> __cur, int<8> __flags) {
    local int<32> __lahead
    local iterator<bytes> __lahstart
    local ref<http_requestline_object> __pobj
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult2

@__b10:
    __lahead = assign 0
    __pobj = new http_requestline_object
    hook.run hook_on_RequestLine___ctor (__pobj)
    debug.msg "binpac-verbose" "bgn start-sym sequence 'T37; T38; T39; T40; T41; T42' with flags %d" (__flags)
    debug.msg "binpac" "RequestLine" ()
    debug.push_indent

    # Parsing non-terminal start_RequestLine
    __presult2 = call http_requestline_sequence_start_requestline (__cur, __pobj, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult2 0
    __lahead = tuple.index __presult2 1
    __lahstart = tuple.index __presult2 2
    debug.msg "binpac-verbose" "end start-sym sequence 'T37; T38; T39; T40; T41; T42'" ()
    debug.pop_indent
    return.result __pobj
    }

export http_requestline_parse

tuple<iterator<bytes>,int<32>,iterator<bytes>> http_requestline_sequence_start_requestline(iterator<bytes> __cur, ref<http_requestline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local iterator<bytes> __next5
    local tuple<iterator<bytes>,int<32>,iterator<bytes>> __presult
    local ref<bytes> __str

@__b11:
    debug.msg "binpac-verbose" "bgn sequence 'terminal_20; <epsilon>'" ()

    # Parse function for production 'T37; T38; T39; T40; T41; T42'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T37
    __presult = call http_requestline_sequence_t37 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_20; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_21; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T38
    __presult = call http_requestline_sequence_t38 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_21; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_22; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T39
    __presult = call http_requestline_sequence_t39 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_22; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_23; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T40
    __presult = call http_requestline_sequence_t40 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_23; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_24; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T41
    __presult = call http_requestline_sequence_t41 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_24; <epsilon>'" ()
    debug.msg "binpac-verbose" "bgn sequence 'terminal_25; <epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing non-terminal T42
    __presult = call http_requestline_sequence_t42 (__cur, __self, __lahead, __lahstart, __flags)
    __cur = tuple.index __presult 0
    __lahead = tuple.index __presult 1
    __lahstart = tuple.index __presult 2
    debug.msg "binpac-verbose" "end sequence 'terminal_25; <epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_requestline_sequence_t37(iterator<bytes> __cur, ref<http_requestline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b12:
    debug.msg "binpac-verbose" "bgn literal '[^ \\t\\r\\n]+ [=: method]'" ()

    # Parse function for production 'terminal_20; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[^ \t\r\n]+'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_requestline_literal_11 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((11, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 11 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac" "method = '%s'" (__token)
    debug.msg "binpac-verbose" "- matched '[^ \\t\\r\\n]+ [=: method]' to '%s'" (__token)
    struct.set __self "method" __token
    debug.msg "binpac-verbose" "end literal '[^ \\t\\r\\n]+ [=: method]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_RequestLine_method (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_requestline_sequence_t38(iterator<bytes> __cur, ref<http_requestline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b13:
    debug.msg "binpac-verbose" "bgn literal '[ \\t]+'" ()

    # Parse function for production 'terminal_21; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[ \t]+'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_requestline_literal_2 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((2, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 2 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac-verbose" "- matched '[ \\t]+' to '%s'" (__token)
    debug.msg "binpac-verbose" "end literal '[ \\t]+'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_RequestLine_anon_45203536 (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_requestline_sequence_t39(iterator<bytes> __cur, ref<http_requestline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b14:
    debug.msg "binpac-verbose" "bgn literal '[^ \\t\\r\\n]+ [=: uri]'" ()

    # Parse function for production 'terminal_22; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[^ \t\r\n]+'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_requestline_literal_11 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((11, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 11 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac" "uri = '%s'" (__token)
    debug.msg "binpac-verbose" "- matched '[^ \\t\\r\\n]+ [=: uri]' to '%s'" (__token)
    struct.set __self "uri" __token
    debug.msg "binpac-verbose" "end literal '[^ \\t\\r\\n]+ [=: uri]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_RequestLine_uri (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_requestline_sequence_t40(iterator<bytes> __cur, ref<http_requestline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b15:
    debug.msg "binpac-verbose" "bgn literal '[ \\t]+'" ()

    # Parse function for production 'terminal_23; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '[ \t]+'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_requestline_literal_2 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((2, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 2 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac-verbose" "- matched '[ \\t]+' to '%s'" (__token)
    debug.msg "binpac-verbose" "end literal '[ \\t]+'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_RequestLine_anon_45204176 (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_requestline_sequence_t41(iterator<bytes> __cur, ref<http_requestline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b16:
    debug.msg "binpac-verbose" "bgn literal 'HTTP\\/[0-9]\\.[0-9] [=: version]'" ()

    # Parse function for production 'terminal_24; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal 'HTTP\/[0-9]\.[0-9]'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_requestline_literal_1 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((1, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 1 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac" "version = '%s'" (__token)
    debug.msg "binpac-verbose" "- matched 'HTTP\\/[0-9]\\.[0-9] [=: version]' to '%s'" (__token)
    struct.set __self "version" __token
    debug.msg "binpac-verbose" "end literal 'HTTP\\/[0-9]\\.[0-9] [=: version]'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_RequestLine_version (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


tuple<iterator<bytes>,int<32>,iterator<bytes>> http_requestline_sequence_t42(iterator<bytes> __cur, ref<http_requestline_object> __self, int<32> __lahead, iterator<bytes> __lahstart, int<8> __flags) {
    local bool __cond
    local int<32> __lahead2
    local tuple<int<32>,iterator<bytes>> __match
    local iterator<bytes> __next5
    local ref<bytes> __str
    local ref<bytes> __token
    local ref<binpac::ParseError> excpt

@__b17:
    debug.msg "binpac-verbose" "bgn literal '\\r?\\n'" ()

    # Parse function for production 'terminal_25; <epsilon>'
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)

    # Parsing literal '\r?\n'
    __cond = equal __lahead 0
    if.else __cond @no_lahead_true @no_lahead_false

@no_lahead_true:
    __lahstart = assign __cur
    __match = regexp.match_token http_requestline_literal_5 __cur
    __lahead2 = tuple.index __match 0
    switch __lahead2 @unexpected_sym ((5, @found_sym), (0, @not_found), (-1, @need_input))

@no_lahead_false:
    # Look-ahead symbol pending, check.
    __cond = equal 5 __lahead
    if.else __cond @check_lahead_true @wrong_lahead

@no_lahead_cont:
    __lahead = assign 0
    __token = bytes.sub __lahstart __cur
    debug.msg "binpac-verbose" "- matched '\\r?\\n' to '%s'" (__token)
    debug.msg "binpac-verbose" "end literal '\\r?\\n'" ()
    debug.msg "binpac-verbose" "bgn epsilon '<epsilon>'" ()
    __next5 = incr_by __cur 5
    __str = bytes.sub __cur __next5
    debug.msg "binpac-verbose" "- input is %s ..." (__str)
    __next5 = incr_by __lahstart 5
    __str = bytes.sub __lahstart __next5
    debug.msg "binpac-verbose" "- lahead start is %s ..." (__str)
    hook.run hook_on_RequestLine_anon_45204816 (__self)
    debug.msg "binpac-verbose" "end epsilon '<epsilon>'" ()
    return.result (__cur, __lahead, __lahstart)

@found_sym:
    __cur = tuple.index __match 1
    jump @no_lahead_cont

@not_found:
    excpt = new binpac::ParseError "look-ahead symbol not found"
    exception.throw excpt

@need_input:
    yield
    jump @no_lahead_true

@unexpected_sym:
    debug.internal_error "unexpected look-ahead symbol returned"

@wrong_lahead:
    excpt = new binpac::ParseError "unexpected look-ahead symbol pending"
    exception.throw excpt

@check_lahead_true:
    # Correct look-ahead symbol pending, will be consumed.
    jump @no_lahead_cont
    }


void init_http() {
@__b72:
    }


export init_http

init void init_http_wrapper() {
    local caddr f
    local tuple<caddr,caddr> funcs

@__b73:
    funcs = caddr.function init_http
    f = tuple.index funcs 0
    call binpacintern::call_init_func (f)
    }


ref<bytes> to_lower_1(ref<bytes> b) {
    local ref<bytes> __result

@__b54:
    __result = call hilti::bytes_to_lower (b)
    return.result __result
    }


declare hook void hook_on_RequestLine_uri(ref<http_requestline_object> __self)
declare hook void hook_on_RequestLine___ctor(ref<http_requestline_object> __self)
declare hook void hook_on_Message_multipart_boundary(ref<http_message_object> __self)
declare hook void hook_on_Message_body(ref<http_message_object> __self)
declare hook void hook_on_ReplyLine_anon_45207504(ref<http_replyline_object> __self)
declare hook void hook_on_Request___ctor(ref<http_request_object> __self)
declare hook void hook_on_Header_anon_45242192(ref<http_header_object> __self, ref<http_message_object> msg)
declare hook void hook_on_Header_name(ref<http_header_object> __self, ref<http_message_object> msg)
hook void hook_on_Request_message(ref<http_request_object> __self) {
    local ref<http_requestline_object> __attr
    local ref<http_message_object> __attr2

@__b74:
    __attr = struct.get __self "request"
    call hilti::print (__attr, True)
    __attr2 = struct.get __self "message"
    call hilti::print (__attr2, True)
    return.void
    }

declare hook void hook_on_RequestLine_anon_45204816(ref<http_requestline_object> __self)
declare hook void hook_on_RequestLine_anon_45203536(ref<http_requestline_object> __self)
declare hook void hook_on_Message_content_type(ref<http_message_object> __self)
declare hook void hook_on_ReplyLine_status(ref<http_replyline_object> __self)
declare hook void hook_on_ReplyLine_reason(ref<http_replyline_object> __self)
declare hook void hook_on_Body_anon_45239760_1(ref<http_body_object> __self, ref<http_message_object> msg, DeliveryMode delivery_mode)
declare hook void hook_on_Chunk_anon_45428112(ref<http_chunk_object> __self)
declare hook void hook_on_Header_anon_45241872(ref<http_header_object> __self, ref<http_message_object> msg)
declare hook void hook_on_Body_data(ref<http_body_object> __self, ref<http_message_object> msg, DeliveryMode delivery_mode)
declare hook void hook_on_Message_delivery_mode(ref<http_message_object> __self)
declare hook void hook_on_Body_anon_45239760(ref<http_body_object> __self, ref<http_message_object> msg, DeliveryMode delivery_mode)
declare hook void hook_on_Message___ctor(ref<http_message_object> __self)
declare hook void hook_on_Header___ctor(ref<http_header_object> __self)
declare hook void hook_on_ReplyLine_anon_45206864(ref<http_replyline_object> __self)
declare hook void hook_on_Message_transfer_encoding(ref<http_message_object> __self)
declare hook void hook_on_Request_request(ref<http_request_object> __self)
declare hook void hook_on_Body_anon_45237008(ref<http_body_object> __self, ref<http_message_object> msg, DeliveryMode delivery_mode)
hook void hook_on_Header_content(ref<http_header_object> __self, ref<http_message_object> msg) {
    local ref<bytes> __attr
    local ref<bytes> __attr2
    local ref<bytes> __attr3
    local ref<bytes> __attr4
    local ref<bytes> __attr5
    local ref<bytes> __attr6
    local bool __equal
    local bool __equal2
    local bool __equal3
    local int<64> __result

@__b79:
    __attr = struct.get __self "name"
    __equal = equal __attr b"content-length"
    if.else __equal @__true @__cont

@__true:
    __attr2 = struct.get __self "content"
    __result = call dec_to_int_1 (__attr2)
    struct.set msg "content_length" __result
    hook.run hook_on_Message_content_length (msg)
    jump @__cont

@__cont:
    __attr3 = struct.get __self "name"
    __equal2 = equal __attr3 b"content-type"
    if.else __equal2 @__true2 @__cont2

@__true2:
    __attr4 = struct.get __self "content"
    struct.set msg "content_type" __attr4
    hook.run hook_on_Message_content_type (msg)
    jump @__cont2

@__cont2:
    __attr5 = struct.get __self "name"
    __equal3 = equal __attr5 b"transfer-encoding"
    if.else __equal3 @__true3 @__cont3

@__true3:
    __attr6 = struct.get __self "content"
    struct.set msg "transfer_encoding" __attr6
    hook.run hook_on_Message_transfer_encoding (msg)
    jump @__cont3

@__cont3:
    return.void
    }

declare hook void hook_on_ReplyLine_anon_45206224(ref<http_replyline_object> __self)
declare hook void hook_on_ReplyLine___ctor(ref<http_replyline_object> __self)
declare hook void hook_on_ReplyLine_version(ref<http_replyline_object> __self)
declare hook void hook_on_RequestLine_method(ref<http_requestline_object> __self)
declare hook void hook_on_Reply_reply(ref<http_reply_object> __self)
declare hook void hook_on_Chunk_anon_45498576(ref<http_chunk_object> __self)
declare hook void hook_on_RequestLine_version(ref<http_requestline_object> __self)
hook void hook_on_Body___ctor(ref<http_body_object> __self, ref<http_message_object> msg, DeliveryMode delivery_mode) {
@__b80:
    struct.set __self "data" b""
    hook.run hook_on_Body_data (__self)
    return.void
    }

declare hook void hook_on_Body_data_3(ref<http_body_object> __self, ref<http_message_object> msg, DeliveryMode delivery_mode)
hook void hook_on_Message_end_of_hdr(ref<http_message_object> __self) {
    local bool __and
    local bool __and2
    local ref<bytes> __attr
    local ref<bytes> __attr2
    local ref<bytes> __attr3
    local ref<bytes> __attr4
    local bool __bool
    local ref<bytes> __copy
    local ref<bytes> __copy2
    local bool __equal
    local bool __has_attr
    local bool __has_attr2
    local bool __has_attr3
    local ref<bytes> __match
    local ref<bytes> __match2
    local bool __nonempty
    local bool __op
    local bool __op2
    local int<32> __size
    local bool __starts
    local ref<bytes> boundary = b""

@__b78:
    __has_attr = struct.is_set __self "content_length"
    if.else __has_attr @__true @__cont

@__true:
    struct.set __self "delivery_mode" DeliveryMode::Length
    hook.run hook_on_Message_delivery_mode (__self)
    jump @__cont

@__cont:
    __has_attr2 = struct.is_set __self "content_type"
    if.else __has_attr2 @and_eval_op2 @and_false

@__true2:
    __attr2 = struct.get __self "content_type"
    __match = call binpacintern::bytes_match (__attr2, /boundary="([^"]*)"/, 1)
    boundary = assign __match
    __size = bytes.length boundary
    __nonempty = equal __size 0
    __nonempty = bool.not __nonempty
    __bool = select __nonempty False True
    if.else __bool @__true3 @__cont3

@__cont2:
    __has_attr3 = struct.is_set __self "transfer_encoding"
    if.else __has_attr3 @and_eval_op22 @and_false2

@and_eval_op2:
    __attr = struct.get __self "content_type"
    __starts = call hilti::bytes_starts_with (__attr, b"multipart/")
    if.else __starts @and_true @and_false

@and_true:
    __and = assign True
    jump @and_cont

@and_false:
    __and = assign False
    jump @and_cont

@and_cont:
    if.else __and @__true2 @__cont2

@__true3:
    __attr3 = struct.get __self "content_type"
    __match2 = call binpacintern::bytes_match (__attr3, /boundary=([^ ;]*)/, 1)
    boundary = assign __match2
    jump @__cont3

@__cont3:
    struct.set __self "delivery_mode" DeliveryMode::Multipart
    hook.run hook_on_Message_delivery_mode (__self)
    __copy = bytes.copy b"--"
    __copy2 = bytes.copy boundary
    bytes.append __copy2 b"--\r\n"
    bytes.append __copy __copy2
    struct.set __self "multipart_boundary" __copy
    hook.run hook_on_Message_multipart_boundary (__self)
    jump @__cont2

@__true4:
    struct.set __self "delivery_mode" DeliveryMode::Chunked
    hook.run hook_on_Message_delivery_mode (__self)
    jump @__cont4

@__cont4:
    return.void

@and_eval_op22:
    __attr4 = struct.get __self "transfer_encoding"
    __equal = equal __attr4 b"chunked"
    if.else __equal @and_true2 @and_false2

@and_true2:
    __and2 = assign True
    jump @and_cont2

@and_false2:
    __and2 = assign False
    jump @and_cont2

@and_cont2:
    if.else __and2 @__true4 @__cont4
    }

declare hook void hook_on_Header_anon_45242832(ref<http_header_object> __self, ref<http_message_object> msg)
declare hook void hook_on_Body_anon_45237008_2(ref<http_body_object> __self, ref<http_message_object> msg, DeliveryMode delivery_mode)
declare hook void hook_on_Chunk_data(ref<http_chunk_object> __self)
declare hook void hook_on_Chunk___ctor(ref<http_chunk_object> __self)
declare hook void hook_on_RequestLine_anon_45204176(ref<http_requestline_object> __self)
hook bool hook_on_Body_anon_45237008_dollardollar(ref<http_body_object> __self, ref<bytes> __dollardollar, ref<http_message_object> msg, DeliveryMode delivery_mode) {
    local ref<bytes> __attr

@__b76:
    __attr = struct.get __self "data"
    bytes.append __attr __dollardollar
    return.void
    }

hook bool hook_on_Body_anon_45237008_dollardollar(ref<http_body_object> __self, ref<bytes> __dollardollar, ref<http_message_object> msg, DeliveryMode delivery_mode) &priority=255  {
    local ref<bytes> __attr
    local bool __equal

@__b83:
    __attr = struct.get msg "multipart_boundary"
    __equal = equal __dollardollar __attr
    if.else __equal @__true @__cont

@__true:
    hook.stop False

@__cont:
    return.void
    }

hook void hook_on_Reply_message(ref<http_reply_object> __self) {
    local ref<http_replyline_object> __attr
    local ref<http_message_object> __attr2

@__b75:
    __attr = struct.get __self "reply"
    call hilti::print (__attr, True)
    __attr2 = struct.get __self "message"
    call hilti::print (__attr2, True)
    return.void
    }

declare hook void hook_on_Message_content_length(ref<http_message_object> __self)
declare hook void hook_on_Message_headers(ref<http_message_object> __self)
declare hook void hook_on_Chunk_length(ref<http_chunk_object> __self)
declare hook void hook_on_Reply___ctor(ref<http_reply_object> __self)
declare hook void hook_on_Body_data_4(ref<http_body_object> __self, ref<http_message_object> msg, DeliveryMode delivery_mode)
hook bool hook_on_Body_anon_45239760_dollardollar(ref<http_body_object> __self, ref<http_chunk_object> __dollardollar, ref<http_message_object> msg, DeliveryMode delivery_mode) {
    local ref<bytes> __attr
    local ref<bytes> __attr2

@__b77:
    __attr = struct.get __self "data"
    __attr2 = struct.get __dollardollar "data"
    bytes.append __attr __attr2
    return.void
    }

hook bool hook_on_Body_anon_45239760_dollardollar(ref<http_body_object> __self, ref<http_chunk_object> __dollardollar, ref<http_message_object> msg, DeliveryMode delivery_mode) &priority=255  {
    local int<64> __attr
    local bool __equal

@__b82:
    __attr = struct.get __dollardollar "length"
    __equal = equal __attr 0
    if.else __equal @__true @__cont

@__true:
    hook.stop False

@__cont:
    return.void
    }

hook bool hook_on_Message_headers_dollardollar(ref<http_message_object> __self, ref<http_header_object> __dollardollar) &priority=254  {
    local ref<list<ref<http_header_object>>> __attr

@__b81:
    __attr = struct.get __self "headers"
    list.push_back __attr __dollardollar
    return.void
    }

