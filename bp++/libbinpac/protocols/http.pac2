# $Id$
#
# TODO: 
#
# - Continued headers
# - b":" instead of /:/

module HTTP;

type DeliveryMode = enum { EndOfData, Length, Multipart, Chunked };

const Token      = /[^ \t\r\n]+/;
const URI        = /[^ \t\r\n]+/;
const NewLine    = /\r?\n/;
const RestOfLine = /[^\r\n]*/;
const FullLine   = /[^\r\n]*\r?\n/;
const Integer    = /[0-9]+/;
const HexInteger = /[0-9a-zA-Z]+/;
const WhiteSpace = /[ \t]+/;
const OptionalWhiteSpace = /[ \t]*/;

bool reply_code_needs_body(status: uint64)
{ 
   return status <= 99 || (status >= 200 && status != 204 && status != 304);
}

export type Requests = unit {
    :  list<Request>;
};

type Request = unit {
    request: RequestLine;
    message: Message(False);
};

export type Replies = unit {
    :  list<Reply>;
};

type Reply = unit {
    reply: ReplyLine;
    message: Message(reply_code_needs_body(self.reply.status));
};

type Version = unit {
    :        /HTTP\//;
    number: /[0-9]+\.[0-9]+/;
};

type RequestLine = unit {
    method:  Token;
    :        WhiteSpace;
    uri:     URI;
    :        WhiteSpace;
    version: Version;
    :        NewLine;
};

%debug on RequestLine::version { 
    print "request", self.method, "|", self.uri, "|", self.version.number;
    }

type ReplyLine = unit {
    version: Version;
    :        WhiteSpace;
    status:  Integer &convert=dec_to_uint;
    :        WhiteSpace;
    reason:  RestOfLine;
    :        NewLine;
};

%debug on ReplyLine::reason { 
    print "reply  ", self.version.number, "|", self.status, "|", self.reason;
    }      

type Message = unit(body_default: bool) {
    headers:    list<Header(self)>;
    end_of_hdr: NewLine;
    body:       Body(self, self.delivery_mode) if ( self.has_body );
    
    var content_length: uint64;
    var content_type: bytes;
    var transfer_encoding: bytes;
    var multipart_boundary: bytes;
    
    var has_body: bool;
    var delivery_mode: DeliveryMode &default=DeliveryMode::EndOfData;

    on %init {
        self.has_body = body_default;
        }

    on end_of_hdr {
        if ( self?.content_length )
            self.delivery_mode = DeliveryMode::Length;

        if ( self?.content_type && (self.content_type).startswith(b"multipart/") ) {
            local boundary : bytes;

            boundary = self.content_type.match(/boundary="([^"]*)"/, 1);
            
            if ( ! |boundary| )
                boundary = self.content_type.match(/boundary=([^ ;]*)/, 1);

            self.delivery_mode = DeliveryMode::Multipart;
            self.multipart_boundary = b"--" + boundary + b"--\r\n";
        }
        
        if ( self?.transfer_encoding && self.transfer_encoding == b"chunked" )
            self.delivery_mode = DeliveryMode::Chunked;
    }
};
    
const HeaderName  = /[^:\r\n]+/;
const HeaderValue = /[^\r\n]+/;

type Header = unit(msg: Message) {
    name:    HeaderName &convert=to_lower;
    :        /:/;
    :        WhiteSpace;
    content: HeaderValue;
    :        NewLine;
    
    on content {
        if ( self.name == b"content-length" ) {
            msg.content_length = dec_to_uint(self.content);
            msg.has_body = True;
            }
                    
        if ( self.name == b"transfer-encoding" ) {
            msg.transfer_encoding = self.content;
            msg.has_body = True;
            }
            
        if ( self.name == b"content-type" )
            msg.content_type = self.content;
        }
};

type Body = unit(msg: Message, delivery_mode: DeliveryMode) {

    switch ( delivery_mode ) {
    
      DeliveryMode::EndOfData -> data: bytes &eod;
      
      DeliveryMode::Length    -> data: bytes &length=msg.content_length;
      
      DeliveryMode::Multipart -> : list<FullLine> &until($$ == msg.multipart_boundary)
                                   foreach { self.data += $$; }
               
      DeliveryMode::Chunked   -> : Chunks(self, msg);       
    };
    
    on %init {
        self.data = b"";
        }
};

type Chunks = unit(body: Body, msg: Message) {
    chunk:   list<Chunk> &until($$.length == 0)
                 foreach { body.data += $$.data; }
    trailer: list<Header(msg)>;
    :        NewLine;
};

type Chunk = unit {
    length:    HexInteger &convert=hex_to_uint;
    :          OptionalWhiteSpace;
    extension: RestOfLine;
    :          NewLine;
    data:      bytes &length=self.length;
    :          NewLine if ( self.length != 0 );
};

# These are implemented in libhilti.
extern int64 Hilti::bytes_to_int(b: bytes, base: uint64);
extern bytes Hilti::bytes_to_lower(b: bytes);

# These will eventually move into libbinpac.
bytes to_lower(b: bytes)
{
     return Hilti::bytes_to_lower(b);
}

uint64 dec_to_uint(b: bytes)
{
     return Hilti::bytes_to_int(b, 10).as_uint();
}

uint64 hex_to_uint(b: bytes)
{
     return Hilti::bytes_to_int(b, 16).as_uint();
}
