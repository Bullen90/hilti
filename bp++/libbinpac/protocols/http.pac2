# $Id$
#
# TODO: 
#
# - Continued headers
# - b":" instead of /:/

module HTTP;

type DeliveryMode = enum { EndOfData, Length, Multipart, Chunked };

const Token      = /[^ \t\r\n]+/;
const URI        = /[^ \t\r\n]+/;
const WhiteSpace = /[ \t]+/;
const NewLine    = /\r?\n/;
const RestOfLine = /[^\r\n]*/;
const FullLine   = /[^\r\n]*\r?\n/;
const Integer    = /[0-9]+/;
const HexInteger = /[0-9a-zA-Z]+/;

export type Request = unit {
    request: RequestLine;
    message: Message {
        # This will move into dedicated debugging hooks later. 
        print self.request;
        print self.message;
        }
};

export type Reply = unit {
    reply: ReplyLine;
    message: Message {
        # This will move into dedicated debugging hooks later. 
        print self.reply;
        print self.message;
        }
};

type RequestLine = unit {
    method:  Token;
    :        WhiteSpace;
    uri:     URI;
    :        WhiteSpace;
    version: Version;
    :        NewLine;
};

const Version = /HTTP\/[0-9]\.[0-9]/;

type ReplyLine = unit {
    version: Version;
    :        WhiteSpace;
    status:  Integer;
    :        WhiteSpace;
    reason:  RestOfLine;
    :        NewLine;
};

type Message = unit {
    headers:    list<Header(self)>;
    end_of_hdr: NewLine;
    body:       Body(self, self.delivery_mode);
    
    var content_length: int64;
    var content_type: bytes;
    var transfer_encoding: bytes;
    var multipart_boundary: bytes;
    
    var delivery_mode: DeliveryMode &default=DeliveryMode::EndOfData;
    
    on end_of_hdr {
        if ( self?.content_length )
            self.delivery_mode = DeliveryMode::Length;

        if ( self?.content_type && self.content_type.startswith(b"multipart/") ) {
            local boundary : bytes;

            boundary = self.content_type.match(/boundary="([^"]*)"/, 1);
            
            if ( ! |boundary| )
                boundary = self.content_type.match(/boundary=([^ ;]*)/, 1);

            self.delivery_mode = DeliveryMode::Multipart;
            self.multipart_boundary = b"--" + boundary + b"--\r\n";
        }
        
        if ( self?.transfer_encoding && self.transfer_encoding == b"chunked" )
            self.delivery_mode = DeliveryMode::Chunked;
    }            
};
    
const HeaderName  = /[^:\r\n]+/;
const HeaderValue = /[^\r\n]+/;

type Header = unit(msg: Message) {
    name:    HeaderName &convert=to_lower;
    :        /:/;
    :        WhiteSpace;
    content: HeaderValue;
    :        NewLine;
    
    on content {
        if ( self.name == b"content-length" )
            msg.content_length = dec_to_int(self.content);
                     
        if ( self.name == b"content-type" )
            msg.content_type = self.content;
                     
        if ( self.name == b"transfer-encoding" )
            msg.transfer_encoding = self.content;
        }
};

type Body = unit(msg: Message, delivery_mode: DeliveryMode) {

    switch ( delivery_mode ) {
    
      DeliveryMode::EndOfData -> data: bytes &eod;
      
      DeliveryMode::Length    -> data: bytes &length=msg.content_length;
      
      DeliveryMode::Multipart -> : list<FullLine> &until($$ == msg.multipart_boundary)
                                   foreach { self.data += $$; }
               
      DeliveryMode::Chunked   -> : list<Chunk> &until($$.length == 0)
                                   foreach { self.data += $$.data; }
       
    }
};

type Chunk = unit {
    length:  HexInteger &convert=hex_to_int;
    :        NewLine;
    data:    bytes &length=self.length;
    :        NewLine if ( self.length != 0 );
};
    
# These are implemented in libhilti.
extern int64 Hilti::bytes_to_int(b: bytes, base: uint64);
extern bytes Hilti::bytes_to_lower(b: bytes);

# These will eventually move into libbinpac.
bytes to_lower(b: bytes)
{
     return Hilti::bytes_to_lower(b);
}

int64 dec_to_int(b: bytes)
{
     return Hilti::bytes_to_int(b, 10);
}

int64 hex_to_int(b: bytes)
{
     return Hilti::bytes_to_int(b, 16);
}
