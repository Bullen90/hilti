// $Id$

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <getopt.h>
#include <pcap.h>

#include <string>

#include <llvm/Module.h>
#include <llvm/PassManager.h>
#include <llvm/ExecutionEngine/ExecutionEngine.h>
#include <llvm/Bitcode/ReaderWriter.h>
#include <llvm/Assembly/PrintModulePass.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/ManagedStatic.h>
#include <llvm/Support/MemoryBuffer.h>
#include <llvm/Support/Streams.h>
#include <llvm/System/Signals.h>

extern "C" {
#include <hilti.h>
#include <hilti_intern.h>
}

const char *Trace;
const char *Filter;
const char *Bitcode;

unsigned long HdrSize = 14; // Ethernet

pcap_t* Pcap = 0;
struct bpf_program* Bpf = 0;
unsigned long PacketCounter = 0;

const char* fmt_log(const char* prefix, const char* fmt, va_list ap)
{
    const int SIZE = 32768;
    static char buffer[SIZE];
    int n = 0;

    n += snprintf(buffer + n, SIZE - n, "%s: ", prefix);
	n += vsnprintf(buffer + n, SIZE - n, fmt, ap);

    strcat(buffer + n, "\n");

    return buffer;
}

void error(const char* fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    const char* msg = fmt_log("error", fmt, ap);
    va_end(ap);
    fputs(msg, stdout);
    exit(1);
}

extern "C" {
static int8_t (*FilterFunction)(__hlt_bytes *, const __hlt_exception *);
}

void readBitcode()
{
    std::string err;
    llvm::Module* module;

    llvm::MemoryBuffer* buffer = llvm::MemoryBuffer::getFileOrSTDIN(Bitcode, &err);
    if ( ! buffer )
        error("cannot read bitcode file %s: %s", Bitcode, err.c_str());

    module = ParseBitcodeFile(buffer, &err);
    if ( ! module )
        error("cannot parse bitcode file %s: %s", Bitcode, err.c_str());

    llvm::ExecutionEngine* engine = llvm::ExecutionEngine::create(module);
    if ( ! engine )
        error("cannot create engine");

    llvm::Function* func = module->getFunction("bpf2hlt_filter");
    if ( ! func )
        error("cannot get function bpf2hlt_filter");

    void* vf = engine->getPointerToFunction(func);

    FilterFunction = (int8_t (*)(__hlt_bytes *, const __hlt_exception *)) vf;
}

void setFilter()
{
    Bpf = new bpf_program;

    if ( pcap_compile(Pcap, Bpf, (char*)Filter, 1, 0) < 0 )
        error("can't compile %s: %s", Filter, pcap_geterr(Pcap));

    if ( pcap_setfilter(Pcap, Bpf) < 0 )
        error("can't set filter: %s", pcap_geterr(Pcap));
}

void pcapOpen()
{
    static char errbuf[PCAP_ERRBUF_SIZE];

    Pcap = pcap_open_offline((char *)Trace, errbuf);

    if ( ! Pcap )
        error("%s", errbuf);

	int dl = pcap_datalink(Pcap);
    if ( dl != DLT_EN10MB )
		error("unknown data link type 0x%x", dl);

    if ( Filter )
        setFilter();
}

bool pcapNext()
{
    struct pcap_pkthdr* hdr;
    const u_char* data;
    int result;

    result = pcap_next_ex(Pcap, &hdr, &data);

    if ( result < 0 )
        // error("no more input");
        return false;

    if ( result == 0 )
        return false;

    if ( Bitcode ) {
        __hlt_exception excpt;

        const int8_t* iphdr = (const int8_t*)(data + HdrSize);
        __hlt_bytes* b = __hlt_bytes_new_from_data(iphdr, hdr->caplen - HdrSize, &excpt);
        if ( ! FilterFunction(b, &excpt) )
            return true;
    }

    ++PacketCounter;

    return true;
}

void pcapClose()
{
    pcap_close(Pcap);
}

void usage()
{
    printf("pktcnt [Options] <input file>\n"
           "\n"
           "  -r| --readfile <trace>         Trace file to read\n"
           "  -f| --filter <filter>          BPF filter for filtering with libpcap\n"
           "  -b| --bitcode <secs>           Bitcode file generated by bpf2hlt + hilti-build\n"
           "\n");

    exit(1);
}

static struct option long_options[] = {
    {"filter", required_argument, 0, 'f'},
    {"bitcode", required_argument, 0, 'b'},
    {"readfile", required_argument, 0, 't'},
    {0, 0, 0, 0}
};

int main(int argc, char **argv)
{
    while (1) {
        char c = getopt_long (argc, argv, "f:b:r:", long_options, 0);

        if ( c == -1 )
            break;

        switch ( c ) {
          case 'f':
            Filter = optarg;
            break;

          case 'b':
            Bitcode = optarg;
            break;

          case 'r':
            Trace = optarg;
            break;

          default:
            usage();
        }
    }

    if ( optind != argc )
        usage();

    if ( ! Trace )
        error("need -r");

    if ( ! (Filter || Bitcode) )
        error("need either -f or -b");

    if ( (Filter && Bitcode) )
        error("can only have one of -f or -b");

    if ( Bitcode )
        readBitcode();

    pcapOpen();

    PacketCounter = 0;

    while ( pcapNext() );

    pcapClose();

    fprintf(stdout, "Number of packets: %lu\n", PacketCounter);

    return 0;
    }



