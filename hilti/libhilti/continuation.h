// $Id$

#ifndef HILTI_CONTINUATION_H
#define HILTI_CONTINUATION_H

struct hlt_execution_context;
struct hlt_exception;

#define HLT_BOUND_FUNCTION_STACK_SIZE 1024 ///< The initial amount of stack size to allocate for bound functions. 

/// A continuation instance. We don't define the attributes further as they
/// aren't usable from C. 
typedef struct hlt_continuation {
    void *succ;
    void *frame;
    void *eoss;
} hlt_continuation;

/// A stack to be used when calling bound function.
typedef struct {
    void* fptr;
    void* eoss;
} hlt_stack;

struct hlt_exception;
struct hlt_excecution_context;

/// A callable is just a special kind of a continuation. It's special because
/// it's not fully initiallized initially.
typedef hlt_continuation hlt_callable;

// This function is generated by the code generator(!).
extern void __hlt_thread_mgr_run_callable(hlt_continuation* cont, struct hlt_exception** excpt, struct hlt_execution_context* ctx);

/// Creates a new stack to be used when we call bound functions. 
/// 
/// size: The size of the stack. If zero, the default ~~HLT_DEFAULT_STACK_SIZE is used.
///
/// excpt: &
/// 
/// Returns: The new stack.
/// 
/// Note: The default stack size is deliberately smaller than what hiltic
/// uses, as these stack are most likely to be used with short call-back functions. 
extern hlt_stack* hlt_stack_new(int size, struct hlt_exception** excpt, struct hlt_execution_context* ctx);

/// Registers a callable to be called at the next possible time. Note that
/// this will not happen before the run-time returns to HILTI-generated code
/// (and then only if that code checks for registered callables).
/// 
/// callable: The callable to be registered.
/// 
/// ctx: The current execution context.
/// 
/// excpt: &
extern void hlt_callable_register(hlt_callable* callable, struct hlt_exception** excpt, struct hlt_execution_context* ctx);

// Returns the next callable registered via hlt_call_callable() that has not
// yet been processed, removing it from the list. Returns null if no further
// callables are pending. This is an internal function used by the code
// generator.  Note that the returned pointer remains only until the next call 
// to either this function or hlt_callable_register().
extern hlt_callable** __hlt_callable_next(struct hlt_execution_context* ctx, struct hlt_exception** excpt);

#endif
