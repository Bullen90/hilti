#! /usr/bin/env bash
#
# Turns a HILTI source into an executable by compiling, assembling, 
# and linking with libhiltimain. 
#
# Honors the following environment variables to pass additional flags 
# on to the corresponding tools:
#
#     HILTICFLAGS
#     LLVMASFLAGS
#     LLVMLDFLAGS
#     CFLAGS

function usage {
   echo "Usage: hilti-build [-m] [-t] [-v] -o <output> <input-files>"
   echo 
   echo "Input files may be end in one of the following extensions:"
   echo "    *.hlt     - HILTI files"
   echo "    *.ll      - LLVM assember file"
   echo "    *.bc      - LLVM bitcode files"
   echo
   echo "Options:"
   echo "    -o         Name of output file; mandatory."
   echo "    -m         Link with libhilti instead of libhiltimain."
   echo "    -t         Do not delete temporary files."
   echo "    -v         Output command lines as they are executed."
   echo "    -O1/O2/O3  Apply optimizations (see 'man opt'); also enables LTO."
   echo "    -l obj.bc  Additional object file to link in."
   echo "    -P         Generate only C prototypes for *.hlt files; does nothing else."
   echo "    -c         Produce a native, linkable object file, not an executable."
   echo "    -b         Produce a bitcode file for JITing."
   echo
   exit 1 
}

function execute {
    if [ "$verbose" != "" ]; then
       echo $@ >>$verbose
    fi

    eval $@
}

function delete_tmps {
     # Delete at exit.
     if [ "$keeptmp" != "1" ]; then
         rm -f $tmpfiles
     fi
}

# Turns *.hlt into *.ll
function compile_hlt {
    input=$1
    dir=`dirname $input`
    base=`basename $input .hlt`
    
    if [ "$protos" == "1" ]; then
        # Just run hiltic to generate the C prototypes.
        doth=$base.h
        execute "hiltic -P $hilticflags $input -o $doth" || exit 1
        result=$doth;
    else
        # Compile *.hlt into *.ll
        ll=$base.ll
        tmpfiles="$tmpfiles $ll"
        execute "hiltic -l $hilticflags -o $ll $input" || exit 1
        result=$ll
    fi
}

# Turns *.ll into *.bc
function compile_ll {
    input=$1
    dir=`dirname $input`
    base=`basename $input .ll`

    if [ "$opt" != "" ]; then
        opt="| opt $opt"
    fi

    bc=$base.bc
    tmpfiles="$tmpfiles $bc"
    execute "llvm-as $llvmasflags < $input $opt >$bc"
    result=$bc
}

# Turns *.c into *.bc
function compile_c {
    input=$1
    dir=`dirname $input`
    base=`basename $input .ll`

    bc=$base.bc
    tmpfiles="$tmpfiles $bc"
    execute "llvm-gcc -c -emit-llvm $opt $cflags -o $bc $input"
    result=$bc
}

# Turns *.cc into *.bc
function compile_cc {
    input=$1
    dir=`dirname $input`
    base=`basename $input .ll`

    bc=$base.bc
    tmpfiles="$tmpfiles $bc"
    execute "llvm-g++ -c -emit-llvm $opt $cxxflags -o $bc $input"
    result=$bc
}

# Links all *.bc together into the final output file.
function link_all {
    bc=$@
    
    if [ "$opt" != "" ]; then
        lto=""
    else
        lto="-disable-opt"
    fi   

    if [ "$bitcode" != "" ]; then
        kind=""
    else
        kind="-native"
        
        if [ "$noexec" != "" ]; then
            exec="-Xlinker=-r"
        else
            exec=""
        fi   
    fi

    execute "llvm-ld $kind $exec $lto $llvmldflags $bc $libs -o $output" || exit 1 
    
    if [ "$bitcode" != "" ]; then
        # llvm-ld will have produces two outputs: (1) a shell script to start
        # lli; and (2) a *.bc file. We only need the latter.
        mv $output.bc $output
    fi
    
}

tmpfiles=""
inputs=""
protos=""
noexec=""
bitcode=""
libsflag="--libs-main"

while [ "$1" != "" ]; do
    case $1 in 
        -m)
            libsflag="--libs" ; shift;;
        -t)
            keeptmp=1; shift;;
        -v)
            verbose=/dev/stderr; shift;;
        -O1) 
            opt=$1; shift;;
        -O2) 
            opt=$1; shift;;
        -O3) 
            opt=$1; shift;;
        -P)
            protos="1"; shift;;
        -o)
            output=$2; shift; shift;; 
        -c)
            noexec="1"; shift;; 
        -b)
            bitcode="1"; shift;; 
        -h) 
            usage;; 
        -*)
            usage;;
        *)
            inputs="$inputs $1"; shift;;
    esac
done    

if [ "$inputs" == "" ]; then
   usage
fi   

if [ "$output" == "" -a "$protos" != "1" ]; then
   echo "name of output file must be given with -o." >&2
   exit 1
fi   

if [ "$TEST_DIAGNOSTICS" != "" ]; then
   keeptmp=1
fi   

trap delete_tmps 0

if [ "$HILTI_CONFIG" != "" ]; then
    hilticonfig=$HILTI_CONFIG
else
    hilticonfig=`which hilti-config 2>/dev/null`
fi    

if [ ! -x "$hilticonfig" ]; then
   echo "cannot find hilti-config; try setting HILTI_CONFIG." >&2
   exit 1
fi

llvmasflags="$LLVMASFLAGS"
hilticflags="`$hilticonfig --hilticflags` $HILTICFLAGS"
llvmldflags="`$hilticonfig --ldflags` $LLVMLDFLAGS"
cflags="`$hilticonfig --cflags` $CFLAGS"
cxxflags="`$hilticonfig --cxxflags` $CFLAGS"
libs=`$hilticonfig $libsflag`

export PYTHONPATH=`$hilticonfig --pythonpath`:$PYTHONPATH

input=$@
objs=""

for file in $inputs; do
    
    if echo $file | grep -q '\.hlt$'; then
       compile_hlt $file
       if [ "$protos" != "1" ]; then
           compile_ll $result
       fi
       objs="$objs $result"
       
    elif echo $file | grep -q '\.ll$'; then
       compile_ll $file
       objs="$objs $result"
       
    elif echo $file | grep -q '\.c$'; then
       compile_c $file
       objs="$objs $result"
       
    elif echo $file | grep -q '\.cc$'; then
       compile_cc $file
       objs="$objs $result"
       
    elif echo $file | grep -q '\.bc$' ; then
       objs="$objs $file"
       
    else
       echo "unknown input type $file"
       exit 1
    fi
    
done

if [ "$protos" == "1" ]; then
   # Nothing else to do.
   exit 0;
fi

link_all $objs
