#! /usr/bin/env python2.6
#
# Generates the instruction reference.

import inspect
import os
import os.path
import sys
import types as builtin_types

import hilti

def openFile(name, title, ts):

    path = os.path.join(dst, name)

    try:
        current = os.path.getmtime(path)
        if current >= ts:
            return None
    except OSError:
        pass

    output = open(path, "w")
    print "Writing %s ..." % name
    print >>output, ".. Automatically generated. Do not edit."
    print >>output, ""

    if title:
        print >>output, title
        print >>output, "-" * len(title)

    return output

def allModules(mod):
    all = []
    for name in sorted(mod.__dict__.keys()):
        mod = codegen.__dict__[name]

        if type(mod) == builtin_types.ModuleType:
            all += [mod]

    return all

def itemize(doc):
    nr = 1
    output = ""
    doc = doc.strip()

    for line in doc.split("\n"):
        if nr == 1:
            output += "* " + line + "\n"
        elif nr == 2:
            indent = 0
            while indent < len(line) and line[indent] in " ":
                indent += 1;
            line = line.strip()
            output += "  " + line + "\n"
        else:
            line = line[indent:]
            output += "  " + line + "\n"

        nr += 1

    return output + "\n"

def safeAdd(dict, idx, val):
    try:
        dict[idx] += [val]
    except KeyError:
        dict[idx] = [val]

def canonicalizeDoc(doc):

    if not doc:
        return ""

    canon = []

    for line in doc.strip().split("\n"):
        line = line.strip()
        line = "    " + line

        canon += [line]

    return "\n".join(canon)

def fmtIns(mnemo, ins, kind):
    ops = []
    params = []

    if not isinstance(ins, hilti.signature.Signature):
        sig = ins._signature
    else:
        sig = ins
        kind = "overload"

    if sig.target():
        ops += ["target"]

    for (num, op) in ((1, sig.op1()), (2, sig.op2()), (3, sig.op3())):

        if op:
            try:
                if op._optional:
                    ops += ["[op%d]" % num]
            except AttributeError:
                ops += ["op%d" % num]

            params += ["    :Operand %d: %s" % (num, sig.getOpDoc(op))]

    if sig.target():
        params += ["    :Target: %s" % sig.getOpDoc(sig.target())]

    s = ""

    if not sig.doc():
        s += ".. hlt:%s:: %s %s\n" % (kind, mnemo, " ".join(ops))
    else:
        s += ".. hlt:%s:: %s\n" % (kind, sig.doc())

    s += "\n"
    s += "\n".join(params) + "\n"
    s += "\n"
    s += canonicalizeDoc(ins.__doc__)
    s += "\n"

    return s

def fmtOverload(ins):
    params = []

    sig = ins._signature
    for (num, op) in ((1, sig.op1()), (2, sig.op2()), (3, sig.op3())):
        if op:
            params += [sig.getOpDoc(op)]

    return "    * %s" % ", ".join(params)

def startGroup(tag, title, docstring, ts):
    out = openFile("hilti-instructions-%s.rst" % tag, None, ts)

    if not out:
        return None

    if title:
        print >>out, fmtGroup(tag, title, docstring)

    return out

def fmtGroup(tag, group, docstring, sec='-'):
    s = ""
    s += group + "\n"
    s += sec * len(group) + "\n\n"

    if tag.startswith("types"):
        (section, subsection) = tag.split("-")
        s += ".. hlt::type %s\n\n" % subsection

    if docstring:
        s += "%s\n" % docstring

    return s

###########################################################

if len(sys.argv) != 2:
    print >>sys.stderr, "usage: gen-instr-reference <dest-dir>"
    sys.exit(1)

dst = sys.argv[1]

sections = {}
instructions = {}
timestamps = {}
newest = 0

def makeIdx(sec, subsec):
    if subsec:
        return "%s-%s" % (sec, subsec)
    else:
        return "main-%s" % sec

for (mnemo, ins) in hilti.instruction.getInstructions().items():

    m = mnemo.split(".")
    prefix = m[0]

    mod = sys.modules[ins.__module__]

    # Internal instructions go straight into the internal section.
    if not prefix:
        section = "internal"
        subsection = None
        title = "Internal Instructions"
        docstring = None

    # See if the module specified which section its instructions should go into.
    elif "_doc_section" in mod.__dict__:
        doc = mod._doc_section

        if (not isinstance(doc, list) and not isinstance(doc, tuple)) or \
           len(doc) != 2:
           print >>sys.stderr, "%s: doc_section not of required type" % mod

        section = doc[0]
        subsection = None
        title = doc[1]
        docstring = mod.__doc__

    else:
        # Default is data types, with one subsection per type.
        section = "types"
        subsection = prefix
        title = prefix
        docstring = mod.__doc__

    # Add instruction to its section.

    idx = makeIdx(section, subsection)

    if not idx in sections:
        sections[idx] = (section, subsection, title, docstring)

    if not idx in instructions:
        instructions[idx] = []

        # See if the module overloads any operators. If so, we insert them
        # into the section as well.
        ops = hilti.instruction.getOverloadsByModule(ins.__module__)
        for op in ops:
            instructions[idx] += [(op.name(), op)]


    instructions[idx] += [(mnemo, ins)]

    # Update timestamp for this section.
    if not idx in timestamps:
        timestamps[idx] = 0

    ts = os.path.getmtime(sys.modules[ins.__module__].__file__)
    timestamps[idx] = max(ts, timestamps[idx])
    newest = max(newest, ts)

#######

for idx in sections:
    (section, subsection, title, docstring) = sections[idx]

    out = startGroup(idx, title, docstring, timestamps[idx])

    if out:
        for (mnemo, ins) in sorted(instructions[idx], key=lambda x: x[0]):
            # Special case operators: they have their own role, and we add all
            # their overloads.
            if inspect.isclass(ins) and issubclass(ins, hilti.instruction.Operator):
                print >>out, fmtIns(mnemo, ins, "operator")

                print >>out, "Overloaded for:\n"

                for i in hilti.instruction.getOverloads(ins):
                    print >>out, fmtOverload(i())

                print >>out, "\n"

            else:
                # Default case.
                print >>out, fmtIns(mnemo, ins, "instruction")

sys.exit(0)

#######

out = startGroup("operators", "Overloaded Operators", "overloaded", newest)

if out:
    for group in ops_overloaded:

        for (mnemo, oper) in sorted(ops_overloaded[group], key=lambda x: x[0]):
            print >>out, fmtIns(mnemo, oper, "operator")

#######

out = startGroup("operators", "Generic Operators", "generic", timestamps["operators"])

if out:
    for (mnemo, ins) in sorted(ops_generic, key=lambda x: x[0]):
        print >>out, fmtGroup(mnemo, sec="^")
        print >>out, fmtIns(mnemo, ins, "operator")

#######

for (name, mod) in hilti.instructions.__dict__.items():

    if name.startswith("_"):
        continue

    try:
        ts = os.path.getmtime(mod.__file__)
    except OSError:
        ts = 0

    postfix = mod.__name__.split(".")[-1]

    out = startGroup("types", None, postfix, ts)

    if out:
        print >>out, mod.__doc__
        print >>out, ""

#######

sys.exit(0)

for name in sorted(hilti.instructions.__all__):

    mod = instructions.__dict__[name]

    try:
        doc = mod._doc_type_description + "\n\n"
        types += mod.__doc__ + "\n\n"
        types += doc
    except AttributeError:
        pass

    reference += """
.. automodule:: hilti.instructions.%s
   :members:
   :undoc-members:

""" % name

sys.exit(0)

output = openFile("instruction-reference.rst")
print >>output, reference

output = openFile("types.rst")
print >>output, types

### Generate docs for the mapping of LLVM types to C types.

cmapping = ""

for mod in allModules(codegen):

    try:
        cmapping += itemize(mod._doc_c_conversion)
    except AttributeError:
        pass

output = openFile("cmapping.rst")
print >>output, cmapping

